{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#welcome-to-pamiq-core-documentation","title":"Welcome to PAMIQ-Core Documentation!","text":"<p>PAMIQ-Core is a framework for building AI agents with real-time learning capabilities through parallel training and inference.</p>"},{"location":"#features","title":"\u2728 Features","text":"<ul> <li>\ud83d\udd04 Parallel Architecture: Simultaneous inference and training in separate threads</li> <li>\u26a1 Real-time Adaptation: Continuously update models during interaction</li> <li>\ud83e\uddf5 Thread-safe Design: Robust synchronization mechanisms for parameter sharing and data transfers</li> <li>\ud83d\udd0c Modular Components: Easy-to-extend agent, environment, and model interfaces</li> <li>\ud83d\udee0\ufe0f Comprehensive Tools: Built-in state persistence, time control, and monitoring</li> <li>\ud83c\udf0d Cross Platform: Linux is the primary focus, but Windows and macOS are also supported. (However, some older macOS and Windows systems may have significantly less accurate time control.)</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code># Basic installation\npip install pamiq-core\n\n# With PyTorch support\npip install pamiq-core[torch]\n</code></pre>"},{"location":"#basic-example","title":"Basic Example","text":"<pre><code>from pamiq_core import launch, Interaction, LaunchConfig\nfrom your_agent import YourAgent\nfrom your_environment import YourEnvironment\n\n# Create agent-environment interaction\ninteraction = Interaction(YourAgent(), YourEnvironment())\n\n# Launch the system\nlaunch(\n    interaction=interaction,\n    models=your_models,\n    data=your_data_buffers,\n    trainers=your_trainers,\n    config=LaunchConfig(\n        web_api_address=(\"localhost\", 8391),\n        max_uptime=300.0,  # 5 minutes\n    ),\n)\n</code></pre> <p>See the samples on GitHub for complete examples.</p>"},{"location":"#remote-cli-control","title":"Remote CLI Control","text":"<p>Once the system is running, you can connect and control it remotely via the terminal using <code>pamiq-console</code>:</p> <pre><code># Connect to local system\npamiq-console --host localhost --port 8391\n\n# Connect to remote system\npamiq-console --host 192.168.1.100 --port 8391\n</code></pre>"},{"location":"#documentation","title":"Documentation","text":"<ul> <li>User Guide: Describes information for working with PAMIQ-Core.</li> <li>API Reference</li> </ul>"},{"location":"#contribution","title":"Contribution","text":"<p>See CONTRIBUTING.md on GitHub</p>"},{"location":"api/console/","title":"Console","text":""},{"location":"api/console/#pamiq_core.console.WebApiServer","title":"pamiq_core.console.WebApiServer","text":"<pre><code>WebApiServer(\n    system_status: SystemStatusProvider,\n    host: str = \"localhost\",\n    port: int = 8391,\n    max_queue_size: int = DEFAULT_QUEUE_SIZE,\n)\n</code></pre> <p>Web API Server for controlling the system.</p> <p>This class provides a simple Web API for controlling the thread controller, allowing external applications to pause, resume, and shutdown the system.</p> API Endpoints <ul> <li> <p>GET /api/status</p> <ul> <li>Returns the current system status.</li> <li>Response: {\"status\": status_name}</li> <li>Status codes: 200 OK, 500 Internal Server Error</li> </ul> </li> <li> <p>POST /api/pause</p> <ul> <li>Pauses the system.</li> <li>Response: {\"result\": \"ok\"} or {\"error\": \"Command queue is full, try again later\"}</li> <li>Status codes: 200 OK, 503 Service Unavailable</li> </ul> </li> <li> <p>POST /api/resume</p> <ul> <li>Resumes the system.</li> <li>Response: {\"result\": \"ok\"} or {\"error\": \"Command queue is full, try again later\"}</li> <li>Status codes: 200 OK, 503 Service Unavailable</li> </ul> </li> <li> <p>POST /api/shutdown</p> <ul> <li>Shuts down the system.</li> <li>Response: {\"result\": \"ok\"} or {\"error\": \"Command queue is full, try again later\"}</li> <li>Status codes: 200 OK, 503 Service Unavailable</li> </ul> </li> <li> <p>POST /api/save-state:</p> <ul> <li>Saves a state of the current system state.</li> <li>Response: {\"result\": \"ok\"} or {\"error\": \"Command queue is full, try again later\"}</li> <li>Status codes: 200 OK, 503 Service Unavailable</li> </ul> </li> </ul> Error Responses <ul> <li>404 Not Found: {\"error\": \"Invalid API endpoint\"}</li> <li>405 Method Not Allowed: {\"error\": \"Invalid API method\"}</li> <li>500 Internal Server Error: {\"error\": \"Internal server error\"}</li> </ul> <p>Initialize the WebApiHandler.</p> PARAMETER DESCRIPTION <code>system_status</code> <p>Provider for system status information.</p> <p> TYPE: <code>SystemStatusProvider</code> </p> <code>host</code> <p>Hostname to run the API server on.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'localhost'</code> </p> <code>port</code> <p>Port to run the API server on.</p> <p> TYPE: <code>int</code> DEFAULT: <code>8391</code> </p> <code>max_queue_size</code> <p>Maximum size of the command queue.</p> <p> TYPE: <code>int</code> DEFAULT: <code>DEFAULT_QUEUE_SIZE</code> </p> Source code in <code>src/pamiq_core/console/web_api.py</code> <pre><code>def __init__(\n    self,\n    system_status: SystemStatusProvider,\n    host: str = \"localhost\",\n    port: int = 8391,\n    max_queue_size: int = DEFAULT_QUEUE_SIZE,\n) -&gt; None:\n    \"\"\"Initialize the WebApiHandler.\n\n    Args:\n        system_status: Provider for system status information.\n        host: Hostname to run the API server on.\n        port: Port to run the API server on.\n        max_queue_size: Maximum size of the command queue.\n    \"\"\"\n    self._logger = logging.getLogger(get_class_module_path(self.__class__))\n    self._system_status = system_status\n    self._host = host\n    self._port = port\n\n    self._received_commands_queue: Queue[ControlCommands] = Queue(\n        maxsize=max_queue_size\n    )\n\n    # Define routes for the Starlette app\n    routes = [\n        Route(\"/api/status\", endpoint=self._get_status, methods=[\"GET\"]),\n        Route(\"/api/pause\", endpoint=self._post_pause, methods=[\"POST\"]),\n        Route(\"/api/resume\", endpoint=self._post_resume, methods=[\"POST\"]),\n        Route(\"/api/shutdown\", endpoint=self._post_shutdown, methods=[\"POST\"]),\n        Route(\n            \"/api/save-state\",\n            endpoint=self._post_save_state,\n            methods=[\"POST\"],\n        ),\n    ]\n\n    # Create Starlette app with routes and exception handlers\n    self._app = Starlette(\n        routes=routes,\n        exception_handlers={\n            404: self._error_404,\n            405: self._error_405,\n            500: self._error_500,\n        },\n    )\n\n    # Setup background thread\n    self._handler_thread = threading.Thread(\n        target=self._run_server, daemon=True, name=\"webapi\"\n    )\n</code></pre>"},{"location":"api/console/#pamiq_core.console.WebApiServer.run_in_background","title":"run_in_background","text":"<pre><code>run_in_background() -&gt; None\n</code></pre> <p>Run the API server in a background thread.</p> Source code in <code>src/pamiq_core/console/web_api.py</code> <pre><code>def run_in_background(self) -&gt; None:\n    \"\"\"Run the API server in a background thread.\"\"\"\n    self._handler_thread.start()\n</code></pre>"},{"location":"api/console/#pamiq_core.console.WebApiServer.has_commands","title":"has_commands","text":"<pre><code>has_commands() -&gt; bool\n</code></pre> <p>Check if there are commands in the queue.</p> RETURNS DESCRIPTION <code>bool</code> <p>True if there are commands, False otherwise.</p> Source code in <code>src/pamiq_core/console/web_api.py</code> <pre><code>def has_commands(self) -&gt; bool:\n    \"\"\"Check if there are commands in the queue.\n\n    Returns:\n        True if there are commands, False otherwise.\n    \"\"\"\n    return not self._received_commands_queue.empty()\n</code></pre>"},{"location":"api/console/#pamiq_core.console.WebApiServer.receive_command","title":"receive_command","text":"<pre><code>receive_command() -&gt; ControlCommands\n</code></pre> <p>Receive a command from the queue without blocking.</p> RETURNS DESCRIPTION <code>ControlCommands</code> <p>The command from the queue.</p> RAISES DESCRIPTION <code>Empty</code> <p>If there are no commands in the queue.</p> Source code in <code>src/pamiq_core/console/web_api.py</code> <pre><code>def receive_command(self) -&gt; ControlCommands:\n    \"\"\"Receive a command from the queue without blocking.\n\n    Returns:\n        The command from the queue.\n\n    Raises:\n        Empty: If there are no commands in the queue.\n    \"\"\"\n    return self._received_commands_queue.get_nowait()\n</code></pre>"},{"location":"api/console/#pamiq_core.console.WebApiClient","title":"pamiq_core.console.WebApiClient","text":"<pre><code>WebApiClient(host: str, port: int)\n</code></pre> <p>Client for PAMIQ Web API communication.</p> <p>Provides methods to interact with PAMIQ system via HTTP API.</p> <p>Initialize Web API client.</p> PARAMETER DESCRIPTION <code>host</code> <p>API server host</p> <p> TYPE: <code>str</code> </p> <code>port</code> <p>API server port</p> <p> TYPE: <code>int</code> </p> Source code in <code>src/pamiq_core/console/web_api.py</code> <pre><code>def __init__(self, host: str, port: int) -&gt; None:\n    \"\"\"Initialize Web API client.\n\n    Args:\n        host: API server host\n        port: API server port\n    \"\"\"\n    self.host = host\n    self.port = port\n    self._client = httpx.Client()\n</code></pre>"},{"location":"api/console/#pamiq_core.console.WebApiClient.get_status","title":"get_status","text":"<pre><code>get_status() -&gt; SystemStatus\n</code></pre> <p>Get system status.</p> RETURNS DESCRIPTION <code>SystemStatus</code> <p>Status enum. If error is occurred, return offline status</p> Source code in <code>src/pamiq_core/console/web_api.py</code> <pre><code>def get_status(self) -&gt; SystemStatus:\n    \"\"\"Get system status.\n\n    Returns:\n        Status enum. If error is occurred, return offline status\n    \"\"\"\n    try:\n        response = self._client.get(f\"{self._base_url}/status\")\n        response.raise_for_status()\n        return SystemStatus(json.loads(response.text)[\"status\"])\n    except (httpx.RequestError, httpx.HTTPStatusError):\n        return SystemStatus.OFFLINE\n</code></pre>"},{"location":"api/console/#pamiq_core.console.WebApiClient.pause","title":"pause","text":"<pre><code>pause() -&gt; str | None\n</code></pre> <p>Pause the system.</p> RETURNS DESCRIPTION <code>str | None</code> <p>Result message or None if request failed</p> Source code in <code>src/pamiq_core/console/web_api.py</code> <pre><code>def pause(self) -&gt; str | None:\n    \"\"\"Pause the system.\n\n    Returns:\n        Result message or None if request failed\n    \"\"\"\n    try:\n        response = self._client.post(f\"{self._base_url}/pause\")\n        response.raise_for_status()\n        return json.loads(response.text)[\"result\"]\n    except (httpx.RequestError, httpx.HTTPStatusError):\n        return None\n</code></pre>"},{"location":"api/console/#pamiq_core.console.WebApiClient.resume","title":"resume","text":"<pre><code>resume() -&gt; str | None\n</code></pre> <p>Resume the system.</p> RETURNS DESCRIPTION <code>str | None</code> <p>Result message or None if request failed</p> Source code in <code>src/pamiq_core/console/web_api.py</code> <pre><code>def resume(self) -&gt; str | None:\n    \"\"\"Resume the system.\n\n    Returns:\n        Result message or None if request failed\n    \"\"\"\n    try:\n        response = self._client.post(f\"{self._base_url}/resume\")\n        response.raise_for_status()\n        return json.loads(response.text)[\"result\"]\n    except (httpx.RequestError, httpx.HTTPStatusError):\n        return None\n</code></pre>"},{"location":"api/console/#pamiq_core.console.WebApiClient.save_state","title":"save_state","text":"<pre><code>save_state() -&gt; str | None\n</code></pre> <p>Save system state.</p> RETURNS DESCRIPTION <code>str | None</code> <p>Result message or None if request failed</p> Source code in <code>src/pamiq_core/console/web_api.py</code> <pre><code>def save_state(self) -&gt; str | None:\n    \"\"\"Save system state.\n\n    Returns:\n        Result message or None if request failed\n    \"\"\"\n    try:\n        response = self._client.post(f\"{self._base_url}/save-state\")\n        response.raise_for_status()\n        return json.loads(response.text)[\"result\"]\n    except (httpx.RequestError, httpx.HTTPStatusError):\n        return None\n</code></pre>"},{"location":"api/console/#pamiq_core.console.WebApiClient.shutdown","title":"shutdown","text":"<pre><code>shutdown() -&gt; str | None\n</code></pre> <p>Shutdown the system.</p> RETURNS DESCRIPTION <code>str | None</code> <p>Result message or None if request failed</p> Source code in <code>src/pamiq_core/console/web_api.py</code> <pre><code>def shutdown(self) -&gt; str | None:\n    \"\"\"Shutdown the system.\n\n    Returns:\n        Result message or None if request failed\n    \"\"\"\n    try:\n        response = self._client.post(f\"{self._base_url}/shutdown\")\n        response.raise_for_status()\n        return json.loads(response.text)[\"result\"]\n    except (httpx.RequestError, httpx.HTTPStatusError):\n        return None\n</code></pre>"},{"location":"api/console/#pamiq_core.console.WebApiClient.close","title":"close","text":"<pre><code>close() -&gt; None\n</code></pre> <p>Close the HTTP client.</p> Source code in <code>src/pamiq_core/console/web_api.py</code> <pre><code>def close(self) -&gt; None:\n    \"\"\"Close the HTTP client.\"\"\"\n    self._client.close()\n</code></pre>"},{"location":"api/console/#pamiq_core.console.SystemStatus","title":"pamiq_core.console.SystemStatus","text":"<p>               Bases: <code>Enum</code></p> <p>Enum representing the system's operational status.</p>"},{"location":"api/console/#pamiq_core.console.SystemStatus.status_name","title":"status_name  <code>property</code>","text":"<pre><code>status_name: str\n</code></pre> <p>Returns the lowercase string representation of the status.</p> RETURNS DESCRIPTION <code>str</code> <p>The lowercase string name of the status.</p>"},{"location":"api/console/#pamiq_core.console.Console","title":"pamiq_core.console.Console","text":"<pre><code>Console(host: str, port: int)\n</code></pre> <p>pamiq-console.</p> <p>Users can Control pamiq with CUI interface interactively.</p> <p>Initialize CUI interface.</p> Source code in <code>src/pamiq_core/console/cui.py</code> <pre><code>def __init__(self, host: str, port: int) -&gt; None:\n    \"\"\"Initialize CUI interface.\"\"\"\n    super().__init__()\n    self._client = WebApiClient(host, port)\n    self.all_commands: list[str] = [\n        attr[len(\"command_\") :] for attr in dir(self) if attr.startswith(\"command_\")\n    ]\n    self._completer = WordCompleter(self.all_commands)\n    self.status = SystemStatus.OFFLINE\n</code></pre>"},{"location":"api/console/#pamiq_core.console.Console.fetch_status","title":"fetch_status","text":"<pre><code>fetch_status() -&gt; None\n</code></pre> <p>Check WebAPI status.</p> Source code in <code>src/pamiq_core/console/cui.py</code> <pre><code>def fetch_status(self) -&gt; None:\n    \"\"\"Check WebAPI status.\"\"\"\n    self.status = self._client.get_status()\n</code></pre>"},{"location":"api/console/#pamiq_core.console.Console.run_command","title":"run_command","text":"<pre><code>run_command(command: str) -&gt; bool | None\n</code></pre> <p>Check connection status before command execution.</p> Source code in <code>src/pamiq_core/console/cui.py</code> <pre><code>def run_command(self, command: str) -&gt; bool | None:\n    \"\"\"Check connection status before command execution.\"\"\"\n    # Update self.status before command execution.\n    self.fetch_status()\n    # Check command depend on WebAPI\n    if command in [\"pause\", \"p\", \"resume\", \"r\", \"save\", \"shutdown\"]:\n        # Check if WebAPI available.\n        if self.status is SystemStatus.OFFLINE:\n            print(f'Command \"{command}\" not executed. Can\\'t connect AMI system.')\n            return False\n    # Execute command\n    loop_end = getattr(self, f\"command_{command}\")()\n    # Update self.status after command execution.\n    self.fetch_status()\n    # If True, main_loop ends.\n    return loop_end\n</code></pre>"},{"location":"api/console/#pamiq_core.console.Console.main_loop","title":"main_loop","text":"<pre><code>main_loop() -&gt; None\n</code></pre> <p>Running CUI interface.</p> Source code in <code>src/pamiq_core/console/cui.py</code> <pre><code>def main_loop(self) -&gt; None:\n    \"\"\"Running CUI interface.\"\"\"\n    print('Welcome to the PAMIQ console. \"help\" lists commands.\\n')\n    while True:\n        self.fetch_status()\n        command = prompt(\n            f\"pamiq-console ({self.status.status_name}) &gt; \",\n            completer=self._completer,\n        )\n        if command == \"\":\n            continue\n        if command in self.all_commands:\n            if self.run_command(command):\n                break\n        else:\n            print(f\"*** Unknown syntax: {command}\")\n</code></pre>"},{"location":"api/console/#pamiq_core.console.Console.command_help","title":"command_help","text":"<pre><code>command_help() -&gt; None\n</code></pre> <p>Show all commands and details.</p> Source code in <code>src/pamiq_core/console/cui.py</code> <pre><code>def command_help(self) -&gt; None:\n    \"\"\"Show all commands and details.\"\"\"\n    print(\n        \"\\n\".join(\n            [\n                \"h/help    Show all commands and details.\",\n                \"p/pause   Pause the AMI system.\",\n                \"r/resume  Resume the AMI system.\",\n                \"save      Save a checkpoint.\",\n                \"shutdown  Shutdown the AMI system.\",\n                \"q/quit    Exit the console.\",\n            ]\n        )\n    )\n</code></pre>"},{"location":"api/console/#pamiq_core.console.Console.command_h","title":"command_h","text":"<pre><code>command_h() -&gt; None\n</code></pre> <p>Show all commands and details.</p> Source code in <code>src/pamiq_core/console/cui.py</code> <pre><code>def command_h(self) -&gt; None:\n    \"\"\"Show all commands and details.\"\"\"\n    self.command_help()\n</code></pre>"},{"location":"api/console/#pamiq_core.console.Console.command_pause","title":"command_pause","text":"<pre><code>command_pause() -&gt; None\n</code></pre> <p>Pause the AMI system.</p> Source code in <code>src/pamiq_core/console/cui.py</code> <pre><code>def command_pause(self) -&gt; None:\n    \"\"\"Pause the AMI system.\"\"\"\n    response = self._client.pause()\n    if response:\n        print(response)\n    else:\n        print(\"Failed to pause...\")\n</code></pre>"},{"location":"api/console/#pamiq_core.console.Console.command_p","title":"command_p","text":"<pre><code>command_p() -&gt; None\n</code></pre> <p>Pause the AMI system.</p> Source code in <code>src/pamiq_core/console/cui.py</code> <pre><code>def command_p(self) -&gt; None:\n    \"\"\"Pause the AMI system.\"\"\"\n    self.command_pause()\n</code></pre>"},{"location":"api/console/#pamiq_core.console.Console.command_resume","title":"command_resume","text":"<pre><code>command_resume() -&gt; None\n</code></pre> <p>Resume the AMI system.</p> Source code in <code>src/pamiq_core/console/cui.py</code> <pre><code>def command_resume(self) -&gt; None:\n    \"\"\"Resume the AMI system.\"\"\"\n    response = self._client.resume()\n    if response:\n        print(response)\n    else:\n        print(\"Failed to resume...\")\n</code></pre>"},{"location":"api/console/#pamiq_core.console.Console.command_r","title":"command_r","text":"<pre><code>command_r() -&gt; None\n</code></pre> <p>Resume the AMI system.</p> Source code in <code>src/pamiq_core/console/cui.py</code> <pre><code>def command_r(self) -&gt; None:\n    \"\"\"Resume the AMI system.\"\"\"\n    self.command_resume()\n</code></pre>"},{"location":"api/console/#pamiq_core.console.Console.command_shutdown","title":"command_shutdown","text":"<pre><code>command_shutdown() -&gt; bool\n</code></pre> <p>Shutdown the AMI system.</p> Source code in <code>src/pamiq_core/console/cui.py</code> <pre><code>def command_shutdown(self) -&gt; bool:\n    \"\"\"Shutdown the AMI system.\"\"\"\n    confirm = input(\"Confirm AMI system shutdown? (y/[N]): \")\n    if confirm.lower() in [\"y\", \"yes\"]:\n        response = self._client.shutdown()\n        if response:\n            return True\n        else:\n            print(\"Failed to shutdown...\")\n    print(\"Shutdown cancelled.\")\n    return False\n</code></pre>"},{"location":"api/console/#pamiq_core.console.Console.command_quit","title":"command_quit","text":"<pre><code>command_quit() -&gt; bool\n</code></pre> <p>Exit the console.</p> Source code in <code>src/pamiq_core/console/cui.py</code> <pre><code>def command_quit(self) -&gt; bool:\n    \"\"\"Exit the console.\"\"\"\n    return True\n</code></pre>"},{"location":"api/console/#pamiq_core.console.Console.command_q","title":"command_q","text":"<pre><code>command_q() -&gt; bool\n</code></pre> <p>Exit the console.</p> Source code in <code>src/pamiq_core/console/cui.py</code> <pre><code>def command_q(self) -&gt; bool:\n    \"\"\"Exit the console.\"\"\"\n    return self.command_quit()\n</code></pre>"},{"location":"api/console/#pamiq_core.console.Console.command_save","title":"command_save","text":"<pre><code>command_save() -&gt; None\n</code></pre> <p>Save a checkpoint.</p> Source code in <code>src/pamiq_core/console/cui.py</code> <pre><code>def command_save(self) -&gt; None:\n    \"\"\"Save a checkpoint.\"\"\"\n    response = self._client.save_state()\n    if response:\n        print(response)\n    else:\n        print(\"Failed to save state...\")\n</code></pre>"},{"location":"api/data/","title":"Data","text":""},{"location":"api/data/#pamiq_core.data.DataBuffer","title":"pamiq_core.data.DataBuffer","text":"<pre><code>DataBuffer(collecting_data_names: Iterable[str], max_size: int)\n</code></pre> <p>               Bases: <code>ABC</code>, <code>PersistentStateMixin</code></p> <p>Interface for managing experience data collected during system execution.</p> <p>DataBuffer provides an interface for collecting and managing experience data generated during system execution. It maintains a buffer of fixed maximum size that stores data for specified data names.</p> <p>Initializes the DataBuffer.</p> PARAMETER DESCRIPTION <code>collecting_data_names</code> <p>Names of data fields to collect and store.</p> <p> TYPE: <code>Iterable[str]</code> </p> <code>max_size</code> <p>Maximum number of samples to store in the buffer.</p> <p> TYPE: <code>int</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If max_size is negative.</p> Source code in <code>src/pamiq_core/data/buffer.py</code> <pre><code>def __init__(self, collecting_data_names: Iterable[str], max_size: int) -&gt; None:\n    \"\"\"Initializes the DataBuffer.\n\n    Args:\n        collecting_data_names: Names of data fields to collect and store.\n        max_size: Maximum number of samples to store in the buffer.\n\n    Raises:\n        ValueError: If max_size is negative.\n    \"\"\"\n    super().__init__()\n    self._collecting_data_names = set(collecting_data_names)\n    if max_size &lt; 0:\n        raise ValueError(\"max_size must be non-negative\")\n    self._max_size = max_size\n</code></pre>"},{"location":"api/data/#pamiq_core.data.DataBuffer.collecting_data_names","title":"collecting_data_names  <code>property</code>","text":"<pre><code>collecting_data_names: set[str]\n</code></pre> <p>Returns the set of data field names being collected.</p>"},{"location":"api/data/#pamiq_core.data.DataBuffer.max_size","title":"max_size  <code>property</code>","text":"<pre><code>max_size: int\n</code></pre> <p>Returns the maximum number of samples that can be stored.</p>"},{"location":"api/data/#pamiq_core.data.DataBuffer.add","title":"add  <code>abstractmethod</code>","text":"<pre><code>add(step_data: StepData[T]) -&gt; None\n</code></pre> <p>Adds a new data sample to the buffer.</p> PARAMETER DESCRIPTION <code>step_data</code> <p>Dictionary containing data for one step. Must contain all fields specified in collecting_data_names.</p> <p> TYPE: <code>StepData[T]</code> </p> Source code in <code>src/pamiq_core/data/buffer.py</code> <pre><code>@abstractmethod\ndef add(self, step_data: StepData[T]) -&gt; None:\n    \"\"\"Adds a new data sample to the buffer.\n\n    Args:\n        step_data: Dictionary containing data for one step. Must contain\n            all fields specified in collecting_data_names.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/data/#pamiq_core.data.DataBuffer.get_data","title":"get_data  <code>abstractmethod</code>","text":"<pre><code>get_data() -&gt; BufferData[T]\n</code></pre> <p>Retrieves all stored data from the buffer.</p> RETURNS DESCRIPTION <code>BufferData[T]</code> <p>Dictionary mapping data field names to sequences of their values.</p> <code>BufferData[T]</code> <p>Each sequence has the same length.</p> Source code in <code>src/pamiq_core/data/buffer.py</code> <pre><code>@abstractmethod\ndef get_data(self) -&gt; BufferData[T]:\n    \"\"\"Retrieves all stored data from the buffer.\n\n    Returns:\n        Dictionary mapping data field names to sequences of their values.\n        Each sequence has the same length.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/data/#pamiq_core.data.DataBuffer.__len__","title":"__len__  <code>abstractmethod</code>","text":"<pre><code>__len__() -&gt; int\n</code></pre> <p>Returns the current number of samples in the buffer.</p> RETURNS DESCRIPTION <code>int</code> <p>The number of samples currently stored in the buffer.</p> <p> TYPE: <code>int</code> </p> Source code in <code>src/pamiq_core/data/buffer.py</code> <pre><code>@abstractmethod\ndef __len__(self) -&gt; int:\n    \"\"\"Returns the current number of samples in the buffer.\n\n    Returns:\n        int: The number of samples currently stored in the buffer.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/data/#pamiq_core.data.DataCollector","title":"pamiq_core.data.DataCollector","text":"<pre><code>DataCollector(user: DataUser[T])\n</code></pre> <p>A thread-safe collector for buffered data.</p> <p>This class provides concurrent data collection capabilities with thread safety, working in conjunction with DataUser to manage data collection and transfer.</p> <p>Initialize DataCollector with a specified DataUser.</p> PARAMETER DESCRIPTION <code>user</code> <p>DataUser instance this collector is associated with.</p> <p> TYPE: <code>DataUser[T]</code> </p> Source code in <code>src/pamiq_core/data/interface.py</code> <pre><code>def __init__(self, user: DataUser[T]) -&gt; None:\n    \"\"\"Initialize DataCollector with a specified DataUser.\n\n    Args:\n        user: DataUser instance this collector is associated with.\n    \"\"\"\n    self._user = user\n    self._queues_dict = user.create_empty_queues()\n    self._lock = RLock()\n</code></pre>"},{"location":"api/data/#pamiq_core.data.DataCollector.collect","title":"collect","text":"<pre><code>collect(step_data: StepData[T]) -&gt; None\n</code></pre> <p>Collect step data in a thread-safe manner.</p> PARAMETER DESCRIPTION <code>step_data</code> <p>Data to be collected.</p> <p> TYPE: <code>StepData[T]</code> </p> Source code in <code>src/pamiq_core/data/interface.py</code> <pre><code>def collect(self, step_data: StepData[T]) -&gt; None:\n    \"\"\"Collect step data in a thread-safe manner.\n\n    Args:\n        step_data: Data to be collected.\n    \"\"\"\n    with self._lock:\n        self._queues_dict.append(step_data)\n</code></pre>"},{"location":"api/data/#pamiq_core.data.DataUser","title":"pamiq_core.data.DataUser","text":"<pre><code>DataUser(buffer: DataBuffer[T])\n</code></pre> <p>               Bases: <code>PersistentStateMixin</code></p> <p>A class that manages data buffering and timestamps for collected data.</p> <p>This class acts as a user of data buffers, handling the collection, storage, and retrieval of data along with their timestamps. It works in conjunction with a DataCollector to manage concurrent data collection.</p> <p>Initialize DataUser with a specified buffer.</p> PARAMETER DESCRIPTION <code>buffer</code> <p>Data buffer instance to store collected data.</p> <p> TYPE: <code>DataBuffer[T]</code> </p> Source code in <code>src/pamiq_core/data/interface.py</code> <pre><code>def __init__(self, buffer: DataBuffer[T]) -&gt; None:\n    \"\"\"Initialize DataUser with a specified buffer.\n\n    Args:\n        buffer: Data buffer instance to store collected data.\n    \"\"\"\n    self._buffer = buffer\n    self._timestamps: deque[float] = deque(maxlen=buffer.max_size)\n    # DataCollector instance is only accessed from DataUser and Container classes\n    self._collector = DataCollector(self)\n</code></pre>"},{"location":"api/data/#pamiq_core.data.DataUser.create_empty_queues","title":"create_empty_queues","text":"<pre><code>create_empty_queues() -&gt; TimestampingQueuesDict[T]\n</code></pre> <p>Create empty timestamping queues for data collection.</p> RETURNS DESCRIPTION <code>TimestampingQueuesDict[T]</code> <p>New instance of TimestampingQueuesDict with appropriate configuration.</p> Source code in <code>src/pamiq_core/data/interface.py</code> <pre><code>def create_empty_queues(self) -&gt; TimestampingQueuesDict[T]:\n    \"\"\"Create empty timestamping queues for data collection.\n\n    Returns:\n        New instance of TimestampingQueuesDict with appropriate configuration.\n    \"\"\"\n    return TimestampingQueuesDict(\n        self._buffer.collecting_data_names, self._buffer.max_size\n    )\n</code></pre>"},{"location":"api/data/#pamiq_core.data.DataUser.update","title":"update","text":"<pre><code>update() -&gt; None\n</code></pre> <p>Update buffer with collected data from the collector.</p> <p>Moves all collected data from the collector to the buffer and records their timestamps.</p> Source code in <code>src/pamiq_core/data/interface.py</code> <pre><code>def update(self) -&gt; None:\n    \"\"\"Update buffer with collected data from the collector.\n\n    Moves all collected data from the collector to the buffer and\n    records their timestamps.\n    \"\"\"\n    queues = self._collector._move_data()  # pyright: ignore[reportPrivateUsage]\n    for _ in range(len(queues)):\n        data, t = queues.popleft()\n        self._buffer.add(data)\n        self._timestamps.append(t)\n</code></pre>"},{"location":"api/data/#pamiq_core.data.DataUser.get_data","title":"get_data","text":"<pre><code>get_data() -&gt; BufferData[T]\n</code></pre> <p>Retrieve data from the buffer.</p> RETURNS DESCRIPTION <code>BufferData[T]</code> <p>Current data stored in the buffer.</p> Source code in <code>src/pamiq_core/data/interface.py</code> <pre><code>def get_data(self) -&gt; BufferData[T]:\n    \"\"\"Retrieve data from the buffer.\n\n    Returns:\n        Current data stored in the buffer.\n    \"\"\"\n    return self._buffer.get_data()\n</code></pre>"},{"location":"api/data/#pamiq_core.data.DataUser.count_data_added_since","title":"count_data_added_since","text":"<pre><code>count_data_added_since(timestamp: float) -&gt; int\n</code></pre> <p>Count the number of data points added after the specified timestamp.</p> <p>NOTE: Use <code>pamiq_core.time</code> to retrieve <code>timestamp</code>.</p> PARAMETER DESCRIPTION <code>timestamp</code> <p>Reference timestamp to count from.</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>int</code> <p>Number of data points added after the specified timestamp.</p> Source code in <code>src/pamiq_core/data/interface.py</code> <pre><code>def count_data_added_since(self, timestamp: float) -&gt; int:\n    \"\"\"Count the number of data points added after the specified timestamp.\n\n    NOTE: Use `pamiq_core.time` to retrieve `timestamp`.\n\n    Args:\n        timestamp: Reference timestamp to count from.\n\n    Returns:\n        Number of data points added after the specified timestamp.\n    \"\"\"\n    for i, t in enumerate(reversed(self._timestamps)):\n        if t &lt;= timestamp:\n            return i\n    return len(self._timestamps)\n</code></pre>"},{"location":"api/data/#pamiq_core.data.DataUser.save_state","title":"save_state","text":"<pre><code>save_state(path: Path) -&gt; None\n</code></pre> <p>Save the state of this DataUser to the specified path.</p> <p>This method first updates the buffer with any pending collected data, then delegates the state saving to the underlying buffer.</p> PARAMETER DESCRIPTION <code>path</code> <p>Directory path where the state should be saved</p> <p> TYPE: <code>Path</code> </p> Source code in <code>src/pamiq_core/data/interface.py</code> <pre><code>@override\ndef save_state(self, path: Path) -&gt; None:\n    \"\"\"Save the state of this DataUser to the specified path.\n\n    This method first updates the buffer with any pending collected data,\n    then delegates the state saving to the underlying buffer.\n\n    Args:\n        path: Directory path where the state should be saved\n    \"\"\"\n    self.update()\n    path.mkdir()\n    self._buffer.save_state(path / \"buffer\")\n    with open(path / \"timestamps.pkl\", \"wb\") as f:\n        pickle.dump(self._timestamps, f)\n</code></pre>"},{"location":"api/data/#pamiq_core.data.DataUser.load_state","title":"load_state","text":"<pre><code>load_state(path: Path) -&gt; None\n</code></pre> <p>Load the state of this DataUser from the specified path.</p> <p>This method delegates the state loading to the underlying buffer.</p> PARAMETER DESCRIPTION <code>path</code> <p>Directory path from where the state should be loaded</p> <p> TYPE: <code>Path</code> </p> Source code in <code>src/pamiq_core/data/interface.py</code> <pre><code>@override\ndef load_state(self, path: Path) -&gt; None:\n    \"\"\"Load the state of this DataUser from the specified path.\n\n    This method delegates the state loading to the underlying buffer.\n\n    Args:\n        path: Directory path from where the state should be loaded\n    \"\"\"\n    self._buffer.load_state(path / \"buffer\")\n    with open(path / \"timestamps.pkl\", \"rb\") as f:\n        self._timestamps = deque(pickle.load(f), maxlen=self._buffer.max_size)\n</code></pre>"},{"location":"api/data/#pamiq_core.data.DataUser.__len__","title":"__len__","text":"<pre><code>__len__() -&gt; int\n</code></pre> <p>Returns the current number of samples in the buffer.</p> Source code in <code>src/pamiq_core/data/interface.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"Returns the current number of samples in the buffer.\"\"\"\n    return len(self._buffer)\n</code></pre>"},{"location":"api/data/#pamiq_core.data.impls.SequentialBuffer","title":"pamiq_core.data.impls.SequentialBuffer","text":"<pre><code>SequentialBuffer(collecting_data_names: Iterable[str], max_size: int)\n</code></pre> <p>               Bases: <code>DataBuffer[T]</code></p> <p>Implementation of DataBuffer that maintains data in sequential order.</p> <p>This buffer stores collected data points in ordered queues, preserving the insertion order. Each data field is stored in a separate queue with a maximum size limit.</p> <p>Initialize a new SequentialBuffer.</p> PARAMETER DESCRIPTION <code>collecting_data_names</code> <p>Names of data fields to collect.</p> <p> TYPE: <code>Iterable[str]</code> </p> <code>max_size</code> <p>Maximum number of data points to store.</p> <p> TYPE: <code>int</code> </p> Source code in <code>src/pamiq_core/data/impls/sequential_buffer.py</code> <pre><code>@override\ndef __init__(self, collecting_data_names: Iterable[str], max_size: int):\n    \"\"\"Initialize a new SequentialBuffer.\n\n    Args:\n        collecting_data_names: Names of data fields to collect.\n        max_size: Maximum number of data points to store.\n    \"\"\"\n    super().__init__(collecting_data_names, max_size)\n\n    self._queues_dict: dict[str, deque[T]] = {\n        name: deque(maxlen=max_size) for name in collecting_data_names\n    }\n\n    self._current_size = 0\n</code></pre>"},{"location":"api/data/#pamiq_core.data.impls.SequentialBuffer.add","title":"add","text":"<pre><code>add(step_data: StepData[T]) -&gt; None\n</code></pre> <p>Add a new data sample to the buffer.</p> PARAMETER DESCRIPTION <code>step_data</code> <p>Dictionary containing data for one step. Must contain all fields specified in collecting_data_names.</p> <p> TYPE: <code>StepData[T]</code> </p> RAISES DESCRIPTION <code>KeyError</code> <p>If a required data field is missing from step_data.</p> Source code in <code>src/pamiq_core/data/impls/sequential_buffer.py</code> <pre><code>@override\ndef add(self, step_data: StepData[T]) -&gt; None:\n    \"\"\"Add a new data sample to the buffer.\n\n    Args:\n        step_data: Dictionary containing data for one step. Must contain\n            all fields specified in collecting_data_names.\n\n    Raises:\n        KeyError: If a required data field is missing from step_data.\n    \"\"\"\n    for name in self.collecting_data_names:\n        if name not in step_data:\n            raise KeyError(f\"Required data '{name}' not found in step_data\")\n        self._queues_dict[name].append(step_data[name])\n\n    if self._current_size &lt; self.max_size:\n        self._current_size += 1\n</code></pre>"},{"location":"api/data/#pamiq_core.data.impls.SequentialBuffer.get_data","title":"get_data","text":"<pre><code>get_data() -&gt; dict[str, list[T]]\n</code></pre> <p>Retrieve all stored data from the buffer.</p> RETURNS DESCRIPTION <code>dict[str, list[T]]</code> <p>Dictionary mapping data field names to lists of their values.</p> <code>dict[str, list[T]]</code> <p>Each list preserves the original insertion order.</p> Source code in <code>src/pamiq_core/data/impls/sequential_buffer.py</code> <pre><code>@override\ndef get_data(self) -&gt; dict[str, list[T]]:\n    \"\"\"Retrieve all stored data from the buffer.\n\n    Returns:\n        Dictionary mapping data field names to lists of their values.\n        Each list preserves the original insertion order.\n    \"\"\"\n    return {name: list(queue) for name, queue in self._queues_dict.items()}\n</code></pre>"},{"location":"api/data/#pamiq_core.data.impls.SequentialBuffer.__len__","title":"__len__","text":"<pre><code>__len__() -&gt; int\n</code></pre> <p>Returns the current number of samples in the buffer.</p> RETURNS DESCRIPTION <code>int</code> <p>The number of samples currently stored in the buffer.</p> <p> TYPE: <code>int</code> </p> Source code in <code>src/pamiq_core/data/impls/sequential_buffer.py</code> <pre><code>@override\ndef __len__(self) -&gt; int:\n    \"\"\"Returns the current number of samples in the buffer.\n\n    Returns:\n        int: The number of samples currently stored in the buffer.\n    \"\"\"\n    return self._current_size\n</code></pre>"},{"location":"api/data/#pamiq_core.data.impls.SequentialBuffer.save_state","title":"save_state","text":"<pre><code>save_state(path: Path) -&gt; None\n</code></pre> <p>Save the buffer state to the specified path.</p> <p>Creates a directory at the given path and saves each data queue as a separate pickle file.</p> PARAMETER DESCRIPTION <code>path</code> <p>Directory path where to save the buffer state</p> <p> TYPE: <code>Path</code> </p> Source code in <code>src/pamiq_core/data/impls/sequential_buffer.py</code> <pre><code>@override\ndef save_state(self, path: Path) -&gt; None:\n    \"\"\"Save the buffer state to the specified path.\n\n    Creates a directory at the given path and saves each data queue as a\n    separate pickle file.\n\n    Args:\n        path: Directory path where to save the buffer state\n    \"\"\"\n    path.mkdir()\n    for name, queue in self._queues_dict.items():\n        with open(path / f\"{name}.pkl\", \"wb\") as f:\n            pickle.dump(queue, f)\n</code></pre>"},{"location":"api/data/#pamiq_core.data.impls.SequentialBuffer.load_state","title":"load_state","text":"<pre><code>load_state(path: Path) -&gt; None\n</code></pre> <p>Load the buffer state from the specified path.</p> <p>Loads data queues from pickle files in the given directory.</p> PARAMETER DESCRIPTION <code>path</code> <p>Directory path from where to load the buffer state</p> <p> TYPE: <code>Path</code> </p> Source code in <code>src/pamiq_core/data/impls/sequential_buffer.py</code> <pre><code>@override\ndef load_state(self, path: Path) -&gt; None:\n    \"\"\"Load the buffer state from the specified path.\n\n    Loads data queues from pickle files in the given directory.\n\n    Args:\n        path: Directory path from where to load the buffer state\n    \"\"\"\n    for name in self.collecting_data_names:\n        with open(path / f\"{name}.pkl\", \"rb\") as f:\n            queue = deque(pickle.load(f), maxlen=self.max_size)\n            self._queues_dict[name] = queue\n</code></pre>"},{"location":"api/data/#pamiq_core.data.impls.RandomReplacementBuffer","title":"pamiq_core.data.impls.RandomReplacementBuffer","text":"<pre><code>RandomReplacementBuffer(\n    collecting_data_names: Iterable[str],\n    max_size: int,\n    replace_probability: float | None = None,\n    expected_survival_length: int | None = None,\n)\n</code></pre> <p>               Bases: <code>DataBuffer[T]</code></p> <p>Buffer implementation that randomly replaces elements when full.</p> <p>This buffer keeps track of collected data and, when full, randomly replaces existing elements based on a configurable probability.</p> <p>Initialize a RandomReplacementBuffer.</p> PARAMETER DESCRIPTION <code>collecting_data_names</code> <p>Names of data fields to collect.</p> <p> TYPE: <code>Iterable[str]</code> </p> <code>max_size</code> <p>Maximum number of data points to store.</p> <p> TYPE: <code>int</code> </p> <code>replace_probability</code> <p>Probability of replacing an existing element when buffer is full. Must be between 0.0 and 1.0 inclusive. If None and expected_survival_length is provided, this will be computed automatically. Default is 1.0 if both are None.</p> <p> TYPE: <code>float | None</code> DEFAULT: <code>None</code> </p> <code>expected_survival_length</code> <p>Expected number of steps that data should survive in the buffer. Used to automatically compute replace_probability if replace_probability is None. Cannot be specified together with replace_probability.</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If replace_probability is not between 0.0 and 1.0 inclusive, or if both replace_probability and expected_survival_length are specified.</p> Source code in <code>src/pamiq_core/data/impls/random_replacement_buffer.py</code> <pre><code>def __init__(\n    self,\n    collecting_data_names: Iterable[str],\n    max_size: int,\n    replace_probability: float | None = None,\n    expected_survival_length: int | None = None,\n) -&gt; None:\n    \"\"\"Initialize a RandomReplacementBuffer.\n\n    Args:\n        collecting_data_names: Names of data fields to collect.\n        max_size: Maximum number of data points to store.\n        replace_probability: Probability of replacing an existing element when buffer is full.\n            Must be between 0.0 and 1.0 inclusive. If None and expected_survival_length is provided,\n            this will be computed automatically. Default is 1.0 if both are None.\n        expected_survival_length: Expected number of steps that data should survive in the buffer.\n            Used to automatically compute replace_probability if replace_probability is None.\n            Cannot be specified together with replace_probability.\n\n    Raises:\n        ValueError: If replace_probability is not between 0.0 and 1.0 inclusive, or if both\n            replace_probability and expected_survival_length are specified.\n    \"\"\"\n    super().__init__(collecting_data_names, max_size)\n\n    if replace_probability is None:\n        if expected_survival_length is None:\n            replace_probability = 1.0\n        else:\n            replace_probability = (\n                self.compute_replace_probability_from_expected_survival_length(\n                    max_size, expected_survival_length\n                )\n            )\n    elif expected_survival_length is not None:\n        raise ValueError(\n            \"Cannot specify both replace_probability and expected_survival_length. \"\n            \"Please specify only one of them.\"\n        )\n    if not (1.0 &gt;= replace_probability &gt;= 0.0):\n        raise ValueError(\n            \"replace_probability must be between 0.0 and 1.0 inclusive\"\n        )\n\n    self._lists_dict: dict[str, list[T]] = {\n        name: [] for name in collecting_data_names\n    }\n\n    self._replace_probability = replace_probability\n    self._current_size = 0\n</code></pre>"},{"location":"api/data/#pamiq_core.data.impls.RandomReplacementBuffer.is_full","title":"is_full  <code>property</code>","text":"<pre><code>is_full: bool\n</code></pre> <p>Check if the buffer has reached its maximum capacity.</p> RETURNS DESCRIPTION <code>bool</code> <p>True if the buffer is full, False otherwise.</p>"},{"location":"api/data/#pamiq_core.data.impls.RandomReplacementBuffer.compute_replace_probability_from_expected_survival_length","title":"compute_replace_probability_from_expected_survival_length  <code>staticmethod</code>","text":"<pre><code>compute_replace_probability_from_expected_survival_length(\n    max_size: int, survival_length: int\n) -&gt; float\n</code></pre> <p>Compute the replace probability from expected survival length.</p> <p>This method calculates the replacement probability needed to achieve a desired expected survival length for data in the buffer.</p> The computation is based on the mathematical analysis described in below <p>https://zenn.dev/gesonanko/scraps/b581e75bfd9f3e</p> PARAMETER DESCRIPTION <code>max_size</code> <p>Maximum size of the buffer.</p> <p> TYPE: <code>int</code> </p> <code>survival_length</code> <p>Expected number of steps that data should survive.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>float</code> <p>The computed replacement probability between 0.0 and 1.0.</p> Source code in <code>src/pamiq_core/data/impls/random_replacement_buffer.py</code> <pre><code>@staticmethod\ndef compute_replace_probability_from_expected_survival_length(\n    max_size: int, survival_length: int\n) -&gt; float:\n    \"\"\"Compute the replace probability from expected survival length.\n\n    This method calculates the replacement probability needed to achieve\n    a desired expected survival length for data in the buffer.\n\n    The computation is based on the mathematical analysis described in below:\n        https://zenn.dev/gesonanko/scraps/b581e75bfd9f3e\n\n    Args:\n        max_size: Maximum size of the buffer.\n        survival_length: Expected number of steps that data should survive.\n\n    Returns:\n        The computed replacement probability between 0.0 and 1.0.\n    \"\"\"\n    gamma = 0.5772156649015329  # Euler-Mascheroni constant\n    p = max_size / survival_length * (math.log(max_size) + gamma)\n    return min(max(p, 0.0), 1.0)  # Clamp value between 0 to 1.\n</code></pre>"},{"location":"api/data/#pamiq_core.data.impls.RandomReplacementBuffer.add","title":"add","text":"<pre><code>add(step_data: StepData[T]) -&gt; None\n</code></pre> <p>Add a new data sample to the buffer.</p> <p>If the buffer is full, the new data may replace an existing entry based on the configured replacement probability.</p> PARAMETER DESCRIPTION <code>step_data</code> <p>Dictionary containing data for one step. Must contain all fields specified in collecting_data_names.</p> <p> TYPE: <code>StepData[T]</code> </p> RAISES DESCRIPTION <code>KeyError</code> <p>If a required data field is missing from step_data.</p> Source code in <code>src/pamiq_core/data/impls/random_replacement_buffer.py</code> <pre><code>@override\ndef add(self, step_data: StepData[T]) -&gt; None:\n    \"\"\"Add a new data sample to the buffer.\n\n    If the buffer is full, the new data may replace an existing entry\n    based on the configured replacement probability.\n\n    Args:\n        step_data: Dictionary containing data for one step. Must contain\n            all fields specified in collecting_data_names.\n\n    Raises:\n        KeyError: If a required data field is missing from step_data.\n    \"\"\"\n    for name in self.collecting_data_names:\n        if name not in step_data:\n            raise KeyError(f\"Required data '{name}' not found in step_data\")\n\n    if self.is_full:\n        if random.random() &gt; self._replace_probability:\n            return\n        replace_index = random.randint(0, self.max_size - 1)\n        for name in self.collecting_data_names:\n            self._lists_dict[name][replace_index] = step_data[name]\n    else:\n        for name in self.collecting_data_names:\n            self._lists_dict[name].append(step_data[name])\n        self._current_size += 1\n</code></pre>"},{"location":"api/data/#pamiq_core.data.impls.RandomReplacementBuffer.get_data","title":"get_data","text":"<pre><code>get_data() -&gt; Mapping[str, list[T]]\n</code></pre> <p>Retrieve all stored data from the buffer.</p> RETURNS DESCRIPTION <code>Mapping[str, list[T]]</code> <p>Dictionary mapping data field names to lists of their values.</p> <code>Mapping[str, list[T]]</code> <p>Returns a copy of the internal data to prevent modification.</p> Source code in <code>src/pamiq_core/data/impls/random_replacement_buffer.py</code> <pre><code>@override\ndef get_data(self) -&gt; Mapping[str, list[T]]:\n    \"\"\"Retrieve all stored data from the buffer.\n\n    Returns:\n        Dictionary mapping data field names to lists of their values.\n        Returns a copy of the internal data to prevent modification.\n    \"\"\"\n    return {name: data.copy() for name, data in self._lists_dict.items()}\n</code></pre>"},{"location":"api/data/#pamiq_core.data.impls.RandomReplacementBuffer.__len__","title":"__len__","text":"<pre><code>__len__() -&gt; int\n</code></pre> <p>Returns the current number of samples in the buffer.</p> RETURNS DESCRIPTION <code>int</code> <p>The number of samples currently stored in the buffer.</p> <p> TYPE: <code>int</code> </p> Source code in <code>src/pamiq_core/data/impls/random_replacement_buffer.py</code> <pre><code>@override\ndef __len__(self) -&gt; int:\n    \"\"\"Returns the current number of samples in the buffer.\n\n    Returns:\n        int: The number of samples currently stored in the buffer.\n    \"\"\"\n    return self._current_size\n</code></pre>"},{"location":"api/data/#pamiq_core.data.impls.RandomReplacementBuffer.save_state","title":"save_state","text":"<pre><code>save_state(path: Path) -&gt; None\n</code></pre> <p>Save the buffer state to the specified path.</p> <p>Creates a directory at the given path and saves each data list as a separate pickle file.</p> PARAMETER DESCRIPTION <code>path</code> <p>Directory path where to save the buffer state.</p> <p> TYPE: <code>Path</code> </p> Source code in <code>src/pamiq_core/data/impls/random_replacement_buffer.py</code> <pre><code>@override\ndef save_state(self, path: Path) -&gt; None:\n    \"\"\"Save the buffer state to the specified path.\n\n    Creates a directory at the given path and saves each data list as a\n    separate pickle file.\n\n    Args:\n        path: Directory path where to save the buffer state.\n    \"\"\"\n    path.mkdir()\n    for name, data in self._lists_dict.items():\n        with open(path / f\"{name}.pkl\", \"wb\") as f:\n            pickle.dump(data, f)\n</code></pre>"},{"location":"api/data/#pamiq_core.data.impls.RandomReplacementBuffer.load_state","title":"load_state","text":"<pre><code>load_state(path: Path) -&gt; None\n</code></pre> <p>Load the buffer state from the specified path.</p> <p>Loads data lists from pickle files in the given directory.</p> PARAMETER DESCRIPTION <code>path</code> <p>Directory path from where to load the buffer state.</p> <p> TYPE: <code>Path</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If loaded data lists have inconsistent lengths.</p> Source code in <code>src/pamiq_core/data/impls/random_replacement_buffer.py</code> <pre><code>@override\ndef load_state(self, path: Path) -&gt; None:\n    \"\"\"Load the buffer state from the specified path.\n\n    Loads data lists from pickle files in the given directory.\n\n    Args:\n        path: Directory path from where to load the buffer state.\n\n    Raises:\n        ValueError: If loaded data lists have inconsistent lengths.\n    \"\"\"\n    lists_dict: dict[str, list[T]] = {}\n    size: int | None = None\n    for name in self.collecting_data_names:\n        with open(path / f\"{name}.pkl\", \"rb\") as f:\n            obj = list(pickle.load(f))[: self.max_size]\n        if size is None:\n            size = len(obj)\n        if size != len(obj):\n            raise ValueError(\"Inconsistent list lengths in loaded data\")\n        lists_dict[name] = obj\n\n    self._lists_dict = lists_dict\n    if size is None:\n        self._current_size = 0\n    else:\n        self._current_size = size\n</code></pre>"},{"location":"api/interaction/","title":"Interaction","text":""},{"location":"api/interaction/#pamiq_core.interaction.Agent","title":"pamiq_core.interaction.Agent","text":"<pre><code>Agent(agents: Mapping[str, Agent[Any, Any]] | None = None)\n</code></pre> <p>               Bases: <code>ABC</code>, <code>InteractionEventMixin</code>, <code>PersistentStateMixin</code>, <code>ThreadEventMixin</code></p> <p>Base agent class for decision making.</p> <p>An agent receives observations from an environment and decides on actions to take in response. This abstract class defines the interface that all agent implementations must follow.</p> <p>Agents can contain child agents that will inherit the parent's inference models and data collectors. State persistence and Thread Event is also propagated to all child agents.</p> <p>Initialize the agent.</p> PARAMETER DESCRIPTION <code>agents</code> <p>Optional mapping of names to child agents. Child agents will inherit inference models and data collectors from the parent, and their states will be saved and loaded together with the parent.</p> <p> TYPE: <code>Mapping[str, Agent[Any, Any]] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/pamiq_core/interaction/agent.py</code> <pre><code>def __init__(self, agents: Mapping[str, Agent[Any, Any]] | None = None) -&gt; None:\n    \"\"\"Initialize the agent.\n\n    Args:\n        agents: Optional mapping of names to child agents. Child agents will inherit\n            inference models and data collectors from the parent, and their states\n            will be saved and loaded together with the parent.\n    \"\"\"\n    self._agents: Mapping[str, Agent[Any, Any]] = {}\n    if agents is not None:\n        self._agents.update(agents)\n</code></pre>"},{"location":"api/interaction/#pamiq_core.interaction.Agent.step","title":"step  <code>abstractmethod</code>","text":"<pre><code>step(observation: ObsType) -&gt; ActType\n</code></pre> <p>Processes an observation and determines the next action.</p> PARAMETER DESCRIPTION <code>observation</code> <p>The current observation from the environment.</p> <p> TYPE: <code>ObsType</code> </p> RETURNS DESCRIPTION <code>ActType</code> <p>The action to take in response to the observation.</p> Source code in <code>src/pamiq_core/interaction/agent.py</code> <pre><code>@abstractmethod\ndef step(self, observation: ObsType) -&gt; ActType:\n    \"\"\"Processes an observation and determines the next action.\n\n    Args:\n        observation: The current observation from the environment.\n\n    Returns:\n        The action to take in response to the observation.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/interaction/#pamiq_core.interaction.Agent.attach_inference_models","title":"attach_inference_models","text":"<pre><code>attach_inference_models(inference_models: InferenceModelsDict) -&gt; None\n</code></pre> <p>Attaches inference models dictionary to this agent.</p> <p>This method is called to provide the agent with access to inference models for decision making. After attaching, the callback method <code>on_inference_models_attached</code> is called. If the agent has child agents, the models are also attached to them.</p> PARAMETER DESCRIPTION <code>inference_models</code> <p>Dictionary of inference models to attach.</p> <p> TYPE: <code>InferenceModelsDict</code> </p> Source code in <code>src/pamiq_core/interaction/agent.py</code> <pre><code>def attach_inference_models(self, inference_models: InferenceModelsDict) -&gt; None:\n    \"\"\"Attaches inference models dictionary to this agent.\n\n    This method is called to provide the agent with access to inference models\n    for decision making. After attaching, the callback method\n    `on_inference_models_attached` is called. If the agent has child agents,\n    the models are also attached to them.\n\n    Args:\n        inference_models: Dictionary of inference models to attach.\n    \"\"\"\n    self._inference_models = inference_models\n    self.on_inference_models_attached()\n    for agent in self._agents.values():\n        agent.attach_inference_models(inference_models)\n</code></pre>"},{"location":"api/interaction/#pamiq_core.interaction.Agent.on_inference_models_attached","title":"on_inference_models_attached","text":"<pre><code>on_inference_models_attached() -&gt; None\n</code></pre> <p>Callback method for when inference models are attached to the agent.</p> <p>Override this method to retrieve DNN models for inference. Use <code>get_inference_model</code> to retrieve a model.</p> Source code in <code>src/pamiq_core/interaction/agent.py</code> <pre><code>def on_inference_models_attached(self) -&gt; None:\n    \"\"\"Callback method for when inference models are attached to the agent.\n\n    Override this method to retrieve DNN models for inference. Use\n    `get_inference_model` to retrieve a model.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/interaction/#pamiq_core.interaction.Agent.attach_data_collectors","title":"attach_data_collectors","text":"<pre><code>attach_data_collectors(data_collectors: DataCollectorsDict) -&gt; None\n</code></pre> <p>Attaches data collectors dictionary to this agent.</p> <p>This method is called to provide the agent with access to data collectors for collecting experience data. After attaching, the callback method <code>on_data_collectors_attached</code> is called. If the agent has child agents, the collectors are also attached to them.</p> PARAMETER DESCRIPTION <code>data_collectors</code> <p>Dictionary of data collectors to attach.</p> <p> TYPE: <code>DataCollectorsDict</code> </p> Source code in <code>src/pamiq_core/interaction/agent.py</code> <pre><code>def attach_data_collectors(self, data_collectors: DataCollectorsDict) -&gt; None:\n    \"\"\"Attaches data collectors dictionary to this agent.\n\n    This method is called to provide the agent with access to data collectors\n    for collecting experience data. After attaching, the callback method\n    `on_data_collectors_attached` is called. If the agent has child agents,\n    the collectors are also attached to them.\n\n    Args:\n        data_collectors: Dictionary of data collectors to attach.\n    \"\"\"\n    self._data_collectors = data_collectors\n    self.on_data_collectors_attached()\n    for agent in self._agents.values():\n        agent.attach_data_collectors(data_collectors)\n</code></pre>"},{"location":"api/interaction/#pamiq_core.interaction.Agent.on_data_collectors_attached","title":"on_data_collectors_attached","text":"<pre><code>on_data_collectors_attached() -&gt; None\n</code></pre> <p>Callback method for when data collectors are attached to this agent.</p> <p>Override this method to set up data collection for the agent. Use <code>get_data_collector</code> to acquire a collector.</p> Source code in <code>src/pamiq_core/interaction/agent.py</code> <pre><code>def on_data_collectors_attached(self) -&gt; None:\n    \"\"\"Callback method for when data collectors are attached to this agent.\n\n    Override this method to set up data collection for the agent. Use\n    `get_data_collector` to acquire a collector.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/interaction/#pamiq_core.interaction.Agent.get_inference_model","title":"get_inference_model","text":"<pre><code>get_inference_model(name: str) -&gt; InferenceModel\n</code></pre> <p>Retrieves an inference model by name.</p> PARAMETER DESCRIPTION <code>name</code> <p>Name of the inference model to retrieve.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>InferenceModel</code> <p>The requested inference model.</p> RAISES DESCRIPTION <code>KeyError</code> <p>If the model with the specified name does not exist.</p> Source code in <code>src/pamiq_core/interaction/agent.py</code> <pre><code>def get_inference_model(self, name: str) -&gt; InferenceModel:\n    \"\"\"Retrieves an inference model by name.\n\n    Args:\n        name: Name of the inference model to retrieve.\n\n    Returns:\n        The requested inference model.\n\n    Raises:\n        KeyError: If the model with the specified name does not exist.\n    \"\"\"\n    return self._inference_models[name]\n</code></pre>"},{"location":"api/interaction/#pamiq_core.interaction.Agent.get_data_collector","title":"get_data_collector","text":"<pre><code>get_data_collector(name: str) -&gt; DataCollector[Any]\n</code></pre> <p>Acquires a data collector by name for exclusive use.</p> <p>This method acquires a data collector for exclusive use within the current step. The collector can only be acquired once at a time.</p> PARAMETER DESCRIPTION <code>name</code> <p>Name of the data collector to acquire.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>DataCollector[Any]</code> <p>The requested data collector.</p> RAISES DESCRIPTION <code>KeyError</code> <p>If the collector is already acquired or not found.</p> Source code in <code>src/pamiq_core/interaction/agent.py</code> <pre><code>def get_data_collector(self, name: str) -&gt; DataCollector[Any]:\n    \"\"\"Acquires a data collector by name for exclusive use.\n\n    This method acquires a data collector for exclusive use within\n    the current step. The collector can only be acquired once at a time.\n\n    Args:\n        name: Name of the data collector to acquire.\n\n    Returns:\n        The requested data collector.\n\n    Raises:\n        KeyError: If the collector is already acquired or not found.\n    \"\"\"\n    return self._data_collectors.acquire(name)\n</code></pre>"},{"location":"api/interaction/#pamiq_core.interaction.Agent.setup","title":"setup","text":"<pre><code>setup() -&gt; None\n</code></pre> <p>Handle interaction setup event.</p> <p>Propagates the event to all child agents.</p> Source code in <code>src/pamiq_core/interaction/agent.py</code> <pre><code>@override\ndef setup(self) -&gt; None:\n    \"\"\"Handle interaction setup event.\n\n    Propagates the event to all child agents.\n    \"\"\"\n    super().setup()\n    for agent in self._agents.values():\n        agent.setup()\n</code></pre>"},{"location":"api/interaction/#pamiq_core.interaction.Agent.teardown","title":"teardown","text":"<pre><code>teardown() -&gt; None\n</code></pre> <p>Handle interaction teardown event.</p> <p>Propagates the event to all child agents.</p> Source code in <code>src/pamiq_core/interaction/agent.py</code> <pre><code>@override\ndef teardown(self) -&gt; None:\n    \"\"\"Handle interaction teardown event.\n\n    Propagates the event to all child agents.\n    \"\"\"\n    super().teardown()\n    for agent in self._agents.values():\n        agent.teardown()\n</code></pre>"},{"location":"api/interaction/#pamiq_core.interaction.Agent.save_state","title":"save_state","text":"<pre><code>save_state(path: Path) -&gt; None\n</code></pre> <p>Save the agent's state and the states of any child agents.</p> PARAMETER DESCRIPTION <code>path</code> <p>Directory path where to save the states.</p> <p> TYPE: <code>Path</code> </p> Source code in <code>src/pamiq_core/interaction/agent.py</code> <pre><code>@override\ndef save_state(self, path: Path) -&gt; None:\n    \"\"\"Save the agent's state and the states of any child agents.\n\n    Args:\n        path: Directory path where to save the states.\n    \"\"\"\n    super().save_state(path)\n    if len(self._agents) == 0:\n        return\n    path.mkdir(exist_ok=True)\n    for name, agent in self._agents.items():\n        agent.save_state(path / name)\n</code></pre>"},{"location":"api/interaction/#pamiq_core.interaction.Agent.load_state","title":"load_state","text":"<pre><code>load_state(path: Path) -&gt; None\n</code></pre> <p>Load the agent's state and the states of any child agents.</p> PARAMETER DESCRIPTION <code>path</code> <p>Directory path from where to load the states.</p> <p> TYPE: <code>Path</code> </p> Source code in <code>src/pamiq_core/interaction/agent.py</code> <pre><code>@override\ndef load_state(self, path: Path) -&gt; None:\n    \"\"\"Load the agent's state and the states of any child agents.\n\n    Args:\n        path: Directory path from where to load the states.\n    \"\"\"\n    super().load_state(path)\n    for name, agent in self._agents.items():\n        agent.load_state(path / name)\n</code></pre>"},{"location":"api/interaction/#pamiq_core.interaction.Agent.on_paused","title":"on_paused","text":"<pre><code>on_paused() -&gt; None\n</code></pre> <p>Handle system pause event.</p> <p>Propagates the pause event to all child agents.</p> Source code in <code>src/pamiq_core/interaction/agent.py</code> <pre><code>@override\ndef on_paused(self) -&gt; None:\n    \"\"\"Handle system pause event.\n\n    Propagates the pause event to all child agents.\n    \"\"\"\n    super().on_paused()\n    for agent in self._agents.values():\n        agent.on_paused()\n</code></pre>"},{"location":"api/interaction/#pamiq_core.interaction.Agent.on_resumed","title":"on_resumed","text":"<pre><code>on_resumed() -&gt; None\n</code></pre> <p>Handle system resume event.</p> <p>Propagates the resume event to all child agents.</p> Source code in <code>src/pamiq_core/interaction/agent.py</code> <pre><code>@override\ndef on_resumed(self) -&gt; None:\n    \"\"\"Handle system resume event.\n\n    Propagates the resume event to all child agents.\n    \"\"\"\n    super().on_resumed()\n    for agent in self._agents.values():\n        agent.on_resumed()\n</code></pre>"},{"location":"api/interaction/#pamiq_core.interaction.Environment","title":"pamiq_core.interaction.Environment","text":"<p>               Bases: <code>ABC</code>, <code>InteractionEventMixin</code>, <code>PersistentStateMixin</code>, <code>ThreadEventMixin</code></p> <p>Base environment class for agent interaction.</p>"},{"location":"api/interaction/#pamiq_core.interaction.Environment.observe","title":"observe  <code>abstractmethod</code>","text":"<pre><code>observe() -&gt; ObsType\n</code></pre> <p>Gets and returns observation from the environment.</p> RETURNS DESCRIPTION <code>ObsType</code> <p>Observation from the environment.</p> Source code in <code>src/pamiq_core/interaction/env.py</code> <pre><code>@abstractmethod\ndef observe(self) -&gt; ObsType:\n    \"\"\"Gets and returns observation from the environment.\n\n    Returns:\n        Observation from the environment.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/interaction/#pamiq_core.interaction.Environment.affect","title":"affect  <code>abstractmethod</code>","text":"<pre><code>affect(action: ActType) -&gt; None\n</code></pre> <p>Applies an action to the environment.</p> PARAMETER DESCRIPTION <code>action</code> <p>Action to apply to the environment.</p> <p> TYPE: <code>ActType</code> </p> Source code in <code>src/pamiq_core/interaction/env.py</code> <pre><code>@abstractmethod\ndef affect(self, action: ActType) -&gt; None:\n    \"\"\"Applies an action to the environment.\n\n    Args:\n        action: Action to apply to the environment.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/interaction/#pamiq_core.interaction.Interaction","title":"pamiq_core.interaction.Interaction","text":"<pre><code>Interaction(agent: Agent[ObsType, ActType], environment: Environment[ObsType, ActType])\n</code></pre> <p>               Bases: <code>InteractionEventMixin</code>, <code>PersistentStateMixin</code>, <code>ThreadEventMixin</code></p> <p>Class that combines an agent and environment to create an interaction loop.</p> <p>This class manages the interaction between an agent and its environment, implementing a basic observe-decide-act loop. It also handles state persistence and lifecycle management for both components.</p> <p>Initialize interaction with an agent and environment.</p> PARAMETER DESCRIPTION <code>agent</code> <p>The agent that makes decisions based on observations.</p> <p> TYPE: <code>Agent[ObsType, ActType]</code> </p> <code>environment</code> <p>The environment that provides observations and receives actions.</p> <p> TYPE: <code>Environment[ObsType, ActType]</code> </p> Source code in <code>src/pamiq_core/interaction/interactions.py</code> <pre><code>def __init__(\n    self, agent: Agent[ObsType, ActType], environment: Environment[ObsType, ActType]\n) -&gt; None:\n    \"\"\"Initialize interaction with an agent and environment.\n\n    Args:\n        agent: The agent that makes decisions based on observations.\n        environment: The environment that provides observations and receives actions.\n    \"\"\"\n    self.agent = agent\n    self.environment = environment\n</code></pre>"},{"location":"api/interaction/#pamiq_core.interaction.Interaction.step","title":"step","text":"<pre><code>step() -&gt; None\n</code></pre> <p>Execute one step of the agent-environment interaction loop.</p> <p>Gets an observation from the environment, passes it to the agent to get an action, and then applies that action to the environment.</p> Source code in <code>src/pamiq_core/interaction/interactions.py</code> <pre><code>def step(self) -&gt; None:\n    \"\"\"Execute one step of the agent-environment interaction loop.\n\n    Gets an observation from the environment, passes it to the agent\n    to get an action, and then applies that action to the\n    environment.\n    \"\"\"\n    obs = self.environment.observe()\n    action = self.agent.step(obs)\n    self.environment.affect(action)\n</code></pre>"},{"location":"api/interaction/#pamiq_core.interaction.Interaction.setup","title":"setup","text":"<pre><code>setup() -&gt; None\n</code></pre> <p>Initialize the interaction by setting up agent and environment.</p> <p>Calls the setup methods of both the agent and environment.</p> Source code in <code>src/pamiq_core/interaction/interactions.py</code> <pre><code>@override\ndef setup(self) -&gt; None:\n    \"\"\"Initialize the interaction by setting up agent and environment.\n\n    Calls the setup methods of both the agent and environment.\n    \"\"\"\n    super().setup()\n    self.agent.setup()\n    self.environment.setup()\n</code></pre>"},{"location":"api/interaction/#pamiq_core.interaction.Interaction.teardown","title":"teardown","text":"<pre><code>teardown() -&gt; None\n</code></pre> <p>Clean up the interaction by tearing down agent and environment.</p> <p>Calls the teardown methods of both the agent and environment.</p> Source code in <code>src/pamiq_core/interaction/interactions.py</code> <pre><code>@override\ndef teardown(self) -&gt; None:\n    \"\"\"Clean up the interaction by tearing down agent and environment.\n\n    Calls the teardown methods of both the agent and environment.\n    \"\"\"\n    super().teardown()\n    self.agent.teardown()\n    self.environment.teardown()\n</code></pre>"},{"location":"api/interaction/#pamiq_core.interaction.Interaction.save_state","title":"save_state","text":"<pre><code>save_state(path: Path) -&gt; None\n</code></pre> <p>Save the current state of the interaction to the specified path.</p> <p>Creates a directory at the given path and saves the states of both the agent and environment in subdirectories.</p> PARAMETER DESCRIPTION <code>path</code> <p>Directory path where to save the interaction state.</p> <p> TYPE: <code>Path</code> </p> Source code in <code>src/pamiq_core/interaction/interactions.py</code> <pre><code>@override\ndef save_state(self, path: Path) -&gt; None:\n    \"\"\"Save the current state of the interaction to the specified path.\n\n    Creates a directory at the given path and saves the states of both\n    the agent and environment in subdirectories.\n\n    Args:\n        path: Directory path where to save the interaction state.\n    \"\"\"\n    path.mkdir()\n    self.agent.save_state(path / \"agent\")\n    self.environment.save_state(path / \"environment\")\n</code></pre>"},{"location":"api/interaction/#pamiq_core.interaction.Interaction.load_state","title":"load_state","text":"<pre><code>load_state(path: Path) -&gt; None\n</code></pre> <p>Load the interaction state from the specified path.</p> <p>Loads the states of both the agent and environment from subdirectories at the given path.</p> PARAMETER DESCRIPTION <code>path</code> <p>Directory path from where to load the interaction state.</p> <p> TYPE: <code>Path</code> </p> Source code in <code>src/pamiq_core/interaction/interactions.py</code> <pre><code>@override\ndef load_state(self, path: Path) -&gt; None:\n    \"\"\"Load the interaction state from the specified path.\n\n    Loads the states of both the agent and environment from subdirectories\n    at the given path.\n\n    Args:\n        path: Directory path from where to load the interaction state.\n    \"\"\"\n    self.agent.load_state(path / \"agent\")\n    self.environment.load_state(path / \"environment\")\n</code></pre>"},{"location":"api/interaction/#pamiq_core.interaction.Interaction.on_paused","title":"on_paused","text":"<pre><code>on_paused() -&gt; None\n</code></pre> <p>The method to be called when the thread is paused.</p> Source code in <code>src/pamiq_core/interaction/interactions.py</code> <pre><code>@override\ndef on_paused(self) -&gt; None:\n    \"\"\"The method to be called when the thread is paused.\"\"\"\n    super().on_paused()\n    self.agent.on_paused()\n    self.environment.on_paused()\n</code></pre>"},{"location":"api/interaction/#pamiq_core.interaction.Interaction.on_resumed","title":"on_resumed","text":"<pre><code>on_resumed() -&gt; None\n</code></pre> <p>The method to be called when the thread is resumed.</p> Source code in <code>src/pamiq_core/interaction/interactions.py</code> <pre><code>@override\ndef on_resumed(self) -&gt; None:\n    \"\"\"The method to be called when the thread is resumed.\"\"\"\n    super().on_resumed()\n    self.agent.on_resumed()\n    self.environment.on_resumed()\n</code></pre>"},{"location":"api/interaction/#pamiq_core.interaction.FixedIntervalInteraction","title":"pamiq_core.interaction.FixedIntervalInteraction","text":"<pre><code>FixedIntervalInteraction(\n    agent: Agent[ObsType, ActType],\n    environment: Environment[ObsType, ActType],\n    adjustor: IntervalAdjustor,\n)\n</code></pre> <p>               Bases: <code>Interaction[ObsType, ActType]</code></p> <p>Interaction class that executes steps at fixed time intervals.</p> <p>This class extends the base Interaction to maintain a consistent timing between steps using an IntervalAdjustor. It ensures the agent-environment interaction loop runs at a specified frequency regardless of how long individual steps take to compute.</p> <p>Initialize the fixed interval interaction.</p> PARAMETER DESCRIPTION <code>agent</code> <p>The agent that makes decisions based on observations.</p> <p> TYPE: <code>Agent[ObsType, ActType]</code> </p> <code>environment</code> <p>The environment that provides observations and receives actions.</p> <p> TYPE: <code>Environment[ObsType, ActType]</code> </p> <code>adjustor</code> <p>The interval adjustor that maintains consistent timing between steps.</p> <p> TYPE: <code>IntervalAdjustor</code> </p> Source code in <code>src/pamiq_core/interaction/interactions.py</code> <pre><code>@override\ndef __init__(\n    self,\n    agent: Agent[ObsType, ActType],\n    environment: Environment[ObsType, ActType],\n    adjustor: IntervalAdjustor,\n) -&gt; None:\n    \"\"\"Initialize the fixed interval interaction.\n\n    Args:\n        agent: The agent that makes decisions based on observations.\n        environment: The environment that provides observations and receives actions.\n        adjustor: The interval adjustor that maintains consistent timing between steps.\n    \"\"\"\n    super().__init__(agent, environment)\n    self._adjustor = adjustor\n</code></pre>"},{"location":"api/interaction/#pamiq_core.interaction.FixedIntervalInteraction.setup","title":"setup","text":"<pre><code>setup() -&gt; None\n</code></pre> <p>Initialize the interaction and reset the interval adjustor.</p> Source code in <code>src/pamiq_core/interaction/interactions.py</code> <pre><code>@override\ndef setup(self) -&gt; None:\n    \"\"\"Initialize the interaction and reset the interval adjustor.\"\"\"\n    super().setup()\n    self._adjustor.reset()\n</code></pre>"},{"location":"api/interaction/#pamiq_core.interaction.FixedIntervalInteraction.step","title":"step","text":"<pre><code>step() -&gt; None\n</code></pre> <p>Execute one step of the interaction and adjust timing.</p> Source code in <code>src/pamiq_core/interaction/interactions.py</code> <pre><code>@override\ndef step(self) -&gt; None:\n    \"\"\"Execute one step of the interaction and adjust timing.\"\"\"\n    super().step()\n    self._adjustor.adjust()\n</code></pre>"},{"location":"api/interaction/#pamiq_core.interaction.FixedIntervalInteraction.with_sleep_adjustor","title":"with_sleep_adjustor  <code>classmethod</code>","text":"<pre><code>with_sleep_adjustor(\n    agent: Agent[ObsType, ActType],\n    environment: Environment[ObsType, ActType],\n    interval: float,\n    offset: float = 0.0,\n) -&gt; Self\n</code></pre> <p>Create a FixedIntervalInteraction with a SleepIntervalAdjustor.</p> PARAMETER DESCRIPTION <code>agent</code> <p>The agent that makes decisions based on observations.</p> <p> TYPE: <code>Agent[ObsType, ActType]</code> </p> <code>environment</code> <p>The environment that provides observations and receives actions.</p> <p> TYPE: <code>Environment[ObsType, ActType]</code> </p> <code>interval</code> <p>The desired time between each step in seconds.</p> <p> TYPE: <code>float</code> </p> <code>offset</code> <p>Optional initial time offset to adjust for system-specific timing differences. Defaults to 0.0.</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.0</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>A new FixedIntervalInteraction instance configured with a SleepIntervalAdjustor.</p> Source code in <code>src/pamiq_core/interaction/interactions.py</code> <pre><code>@classmethod\ndef with_sleep_adjustor(\n    cls,\n    agent: Agent[ObsType, ActType],\n    environment: Environment[ObsType, ActType],\n    interval: float,\n    offset: float = 0.0,\n) -&gt; Self:\n    \"\"\"Create a FixedIntervalInteraction with a SleepIntervalAdjustor.\n\n    Args:\n        agent: The agent that makes decisions based on observations.\n        environment: The environment that provides observations and receives actions.\n        interval: The desired time between each step in seconds.\n        offset: Optional initial time offset to adjust for system-specific timing differences.\n            Defaults to 0.0.\n\n    Returns:\n        A new FixedIntervalInteraction instance configured with a SleepIntervalAdjustor.\n    \"\"\"\n    return cls(agent, environment, SleepIntervalAdjustor(interval, offset))\n</code></pre>"},{"location":"api/interaction/#pamiq_core.interaction.interval_adjustors","title":"pamiq_core.interaction.interval_adjustors","text":""},{"location":"api/interaction/#pamiq_core.interaction.interval_adjustors.IntervalAdjustor","title":"IntervalAdjustor","text":"<pre><code>IntervalAdjustor(interval: float, offset: float = 0.0)\n</code></pre> <p>               Bases: <code>ABC</code></p> <p>Adjusts the loop to run at a fixed interval.</p> <p>Initial reset time is set to negative infinity for mathematical reasons.</p> <p>Constructs the IntervalAdjustor.</p> PARAMETER DESCRIPTION <code>interval</code> <p>The desired time between each invocation in seconds.</p> <p> TYPE: <code>float</code> </p> <code>offset</code> <p>The initial time offset to subtract from the interval on the first loop iteration, allowing adjustment of the actual interval for each computer using this parameter.</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.0</code> </p> Source code in <code>src/pamiq_core/interaction/interval_adjustors.py</code> <pre><code>def __init__(self, interval: float, offset: float = 0.0) -&gt; None:\n    \"\"\"Constructs the IntervalAdjustor.\n\n    Args:\n        interval: The desired time between each invocation in seconds.\n        offset: The initial time offset to subtract from the interval on the first loop iteration,\n            allowing adjustment of the actual interval for each computer using this parameter.\n    \"\"\"\n    self._interval = interval\n    self._offset = offset\n    self._time_to_wait = interval - offset\n</code></pre>"},{"location":"api/interaction/#pamiq_core.interaction.interval_adjustors.IntervalAdjustor.reset","title":"reset","text":"<pre><code>reset() -&gt; float\n</code></pre> <p>Resets the start time of this adjustor to the current time.</p> RETURNS DESCRIPTION <code>float</code> <p>The start time after resetting the timer, as a high precision time counter.</p> <p> TYPE: <code>float</code> </p> Source code in <code>src/pamiq_core/interaction/interval_adjustors.py</code> <pre><code>def reset(self) -&gt; float:\n    \"\"\"Resets the start time of this adjustor to the current time.\n\n    Returns:\n        float: The start time after resetting the timer, as a high precision time counter.\n    \"\"\"\n    self._last_reset_time = time.perf_counter()\n    return self._last_reset_time\n</code></pre>"},{"location":"api/interaction/#pamiq_core.interaction.interval_adjustors.IntervalAdjustor.adjust_impl","title":"adjust_impl  <code>abstractmethod</code>","text":"<pre><code>adjust_impl() -&gt; None\n</code></pre> <p>The actual implementation of the interval adjustor, which is wrapped by the public method <code>adjust</code>.</p> Source code in <code>src/pamiq_core/interaction/interval_adjustors.py</code> <pre><code>@abstractmethod\ndef adjust_impl(self) -&gt; None:\n    \"\"\"The actual implementation of the interval adjustor, which is wrapped\n    by the public method `adjust`.\"\"\"\n    pass\n</code></pre>"},{"location":"api/interaction/#pamiq_core.interaction.interval_adjustors.IntervalAdjustor.adjust","title":"adjust","text":"<pre><code>adjust() -&gt; float\n</code></pre> <p>Waits until the interval has elapsed since the last <code>adjust</code> or <code>reset</code> call.</p> RETURNS DESCRIPTION <code>float</code> <p>The elapsed time since the last call, ensuring the loop runs at the specified interval.</p> <p> TYPE: <code>float</code> </p> Source code in <code>src/pamiq_core/interaction/interval_adjustors.py</code> <pre><code>def adjust(self) -&gt; float:\n    \"\"\"Waits until the interval has elapsed since the last `adjust` or\n    `reset` call.\n\n    Returns:\n        float: The elapsed time since the last call, ensuring the loop runs at the specified interval.\n    \"\"\"\n    self.adjust_impl()\n    delta_time = time.perf_counter() - self._last_reset_time\n    self.reset()\n    return delta_time\n</code></pre>"},{"location":"api/interaction/#pamiq_core.interaction.interval_adjustors.SleepIntervalAdjustor","title":"SleepIntervalAdjustor","text":"<pre><code>SleepIntervalAdjustor(interval: float, offset: float = 0.0)\n</code></pre> <p>               Bases: <code>IntervalAdjustor</code></p> <p>Adjusts the interval using <code>time.sleep</code> to pause execution until the next interval begins.</p> Source code in <code>src/pamiq_core/interaction/interval_adjustors.py</code> <pre><code>def __init__(self, interval: float, offset: float = 0.0) -&gt; None:\n    \"\"\"Constructs the IntervalAdjustor.\n\n    Args:\n        interval: The desired time between each invocation in seconds.\n        offset: The initial time offset to subtract from the interval on the first loop iteration,\n            allowing adjustment of the actual interval for each computer using this parameter.\n    \"\"\"\n    self._interval = interval\n    self._offset = offset\n    self._time_to_wait = interval - offset\n</code></pre>"},{"location":"api/interaction/#pamiq_core.interaction.modular_env","title":"pamiq_core.interaction.modular_env","text":""},{"location":"api/interaction/#pamiq_core.interaction.modular_env.Sensor","title":"Sensor","text":"<p>               Bases: <code>ABC</code>, <code>InteractionEventMixin</code>, <code>PersistentStateMixin</code>, <code>ThreadEventMixin</code></p> <p>Abstract base class for sensors that read data from the environment.</p> <p>This class provides an interface for reading observations from various sensors. Implementations should handle the specific logic for acquiring sensor readings.</p>"},{"location":"api/interaction/#pamiq_core.interaction.modular_env.Sensor.read","title":"read  <code>abstractmethod</code>","text":"<pre><code>read() -&gt; T\n</code></pre> <p>Read data from the sensor.</p> RETURNS DESCRIPTION <code>T</code> <p>Sensor reading/observation data.</p> Source code in <code>src/pamiq_core/interaction/modular_env.py</code> <pre><code>@abstractmethod\ndef read(self) -&gt; T:\n    \"\"\"Read data from the sensor.\n\n    Returns:\n        Sensor reading/observation data.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/interaction/#pamiq_core.interaction.modular_env.Actuator","title":"Actuator","text":"<p>               Bases: <code>ABC</code>, <code>InteractionEventMixin</code>, <code>PersistentStateMixin</code>, <code>ThreadEventMixin</code></p> <p>Abstract base class for actuators that affect the environment.</p> <p>This class provides an interface for operating actuators based on action commands. Implementations should handle the specific logic for executing actions through hardware or simulation interfaces.</p>"},{"location":"api/interaction/#pamiq_core.interaction.modular_env.Actuator.operate","title":"operate  <code>abstractmethod</code>","text":"<pre><code>operate(action: T) -&gt; None\n</code></pre> <p>Execute the specified action through the actuator.</p> PARAMETER DESCRIPTION <code>action</code> <p>The action to be executed.</p> <p> TYPE: <code>T</code> </p> Source code in <code>src/pamiq_core/interaction/modular_env.py</code> <pre><code>@abstractmethod\ndef operate(self, action: T) -&gt; None:\n    \"\"\"Execute the specified action through the actuator.\n\n    Args:\n        action: The action to be executed.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/interaction/#pamiq_core.interaction.modular_env.ModularEnvironment","title":"ModularEnvironment","text":"<pre><code>ModularEnvironment(sensor: Sensor[ObsType], actuator: Actuator[ActType])\n</code></pre> <p>               Bases: <code>Environment[ObsType, ActType]</code></p> <p>Environment implementation that uses a Sensor and Actuator.</p> <p>This class provides a modular approach to environment implementation by separating the sensing (observation) and actuation components.</p> <p>Initialize with a sensor and actuator.</p> PARAMETER DESCRIPTION <code>sensor</code> <p>Component to read observations from the environment.</p> <p> TYPE: <code>Sensor[ObsType]</code> </p> <code>actuator</code> <p>Component to execute actions in the environment.</p> <p> TYPE: <code>Actuator[ActType]</code> </p> Source code in <code>src/pamiq_core/interaction/modular_env.py</code> <pre><code>@override\ndef __init__(self, sensor: Sensor[ObsType], actuator: Actuator[ActType]) -&gt; None:\n    \"\"\"Initialize with a sensor and actuator.\n\n    Args:\n        sensor: Component to read observations from the environment.\n        actuator: Component to execute actions in the environment.\n    \"\"\"\n    self.sensor = sensor\n    self.actuator = actuator\n</code></pre>"},{"location":"api/interaction/#pamiq_core.interaction.modular_env.ModularEnvironment.observe","title":"observe","text":"<pre><code>observe() -&gt; ObsType\n</code></pre> <p>Get observations from the environment using the sensor.</p> RETURNS DESCRIPTION <code>ObsType</code> <p>Current observation from the sensor.</p> Source code in <code>src/pamiq_core/interaction/modular_env.py</code> <pre><code>@override\ndef observe(self) -&gt; ObsType:\n    \"\"\"Get observations from the environment using the sensor.\n\n    Returns:\n        Current observation from the sensor.\n    \"\"\"\n    return self.sensor.read()\n</code></pre>"},{"location":"api/interaction/#pamiq_core.interaction.modular_env.ModularEnvironment.affect","title":"affect","text":"<pre><code>affect(action: ActType) -&gt; None\n</code></pre> <p>Apply an action to the environment using the actuator.</p> PARAMETER DESCRIPTION <code>action</code> <p>The action to apply to the environment.</p> <p> TYPE: <code>ActType</code> </p> Source code in <code>src/pamiq_core/interaction/modular_env.py</code> <pre><code>@override\ndef affect(self, action: ActType) -&gt; None:\n    \"\"\"Apply an action to the environment using the actuator.\n\n    Args:\n        action: The action to apply to the environment.\n    \"\"\"\n    self.actuator.operate(action)\n</code></pre>"},{"location":"api/interaction/#pamiq_core.interaction.modular_env.ModularEnvironment.setup","title":"setup","text":"<pre><code>setup() -&gt; None\n</code></pre> <p>Set up the environment by initializing sensor and actuator.</p> <p>This method is called before starting interaction with the environment.</p> Source code in <code>src/pamiq_core/interaction/modular_env.py</code> <pre><code>@override\ndef setup(self) -&gt; None:\n    \"\"\"Set up the environment by initializing sensor and actuator.\n\n    This method is called before starting interaction with the\n    environment.\n    \"\"\"\n    self.sensor.setup()\n    self.actuator.setup()\n</code></pre>"},{"location":"api/interaction/#pamiq_core.interaction.modular_env.ModularEnvironment.teardown","title":"teardown","text":"<pre><code>teardown() -&gt; None\n</code></pre> <p>Clean up the environment by finalizing sensor and actuator.</p> <p>This method is called after finishing interaction with the environment.</p> Source code in <code>src/pamiq_core/interaction/modular_env.py</code> <pre><code>@override\ndef teardown(self) -&gt; None:\n    \"\"\"Clean up the environment by finalizing sensor and actuator.\n\n    This method is called after finishing interaction with the\n    environment.\n    \"\"\"\n    self.sensor.teardown()\n    self.actuator.teardown()\n</code></pre>"},{"location":"api/interaction/#pamiq_core.interaction.modular_env.ModularEnvironment.save_state","title":"save_state","text":"<pre><code>save_state(path: Path) -&gt; None\n</code></pre> <p>Save the state of the environment to the specified path.</p> <p>Creates a directory at the given path and saves the states of the sensor and actuator in subdirectories.</p> PARAMETER DESCRIPTION <code>path</code> <p>Directory path where to save the environment state.</p> <p> TYPE: <code>Path</code> </p> Source code in <code>src/pamiq_core/interaction/modular_env.py</code> <pre><code>@override\ndef save_state(self, path: Path) -&gt; None:\n    \"\"\"Save the state of the environment to the specified path.\n\n    Creates a directory at the given path and saves the states of\n    the sensor and actuator in subdirectories.\n\n    Args:\n        path: Directory path where to save the environment state.\n    \"\"\"\n    path.mkdir()\n    self.sensor.save_state(path / \"sensor\")\n    self.actuator.save_state(path / \"actuator\")\n</code></pre>"},{"location":"api/interaction/#pamiq_core.interaction.modular_env.ModularEnvironment.load_state","title":"load_state","text":"<pre><code>load_state(path: Path) -&gt; None\n</code></pre> <p>Load the state of the environment from the specified path.</p> <p>Loads the states of the sensor and actuator from subdirectories at the given path.</p> PARAMETER DESCRIPTION <code>path</code> <p>Directory path from where to load the environment state.</p> <p> TYPE: <code>Path</code> </p> Source code in <code>src/pamiq_core/interaction/modular_env.py</code> <pre><code>@override\ndef load_state(self, path: Path) -&gt; None:\n    \"\"\"Load the state of the environment from the specified path.\n\n    Loads the states of the sensor and actuator from subdirectories\n    at the given path.\n\n    Args:\n        path: Directory path from where to load the environment state.\n    \"\"\"\n    self.sensor.load_state(path / \"sensor\")\n    self.actuator.load_state(path / \"actuator\")\n</code></pre>"},{"location":"api/interaction/#pamiq_core.interaction.modular_env.ModularEnvironment.on_paused","title":"on_paused","text":"<pre><code>on_paused() -&gt; None\n</code></pre> <p>The method to be called when the thread is paused.</p> Source code in <code>src/pamiq_core/interaction/modular_env.py</code> <pre><code>@override\ndef on_paused(self) -&gt; None:\n    \"\"\"The method to be called when the thread is paused.\"\"\"\n    super().on_paused()\n    self.sensor.on_paused()\n    self.actuator.on_paused()\n</code></pre>"},{"location":"api/interaction/#pamiq_core.interaction.modular_env.ModularEnvironment.on_resumed","title":"on_resumed","text":"<pre><code>on_resumed() -&gt; None\n</code></pre> <p>The method to be called when the thread is resumed.</p> Source code in <code>src/pamiq_core/interaction/modular_env.py</code> <pre><code>@override\ndef on_resumed(self) -&gt; None:\n    \"\"\"The method to be called when the thread is resumed.\"\"\"\n    super().on_resumed()\n    self.sensor.on_resumed()\n    self.actuator.on_resumed()\n</code></pre>"},{"location":"api/interaction/#pamiq_core.interaction.modular_env.ModularEnvironment.from_dict","title":"from_dict  <code>staticmethod</code>","text":"<pre><code>from_dict(\n    sensors: Mapping[str, Sensor[Any]], actuators: Mapping[str, Actuator[Any]]\n) -&gt; ModularEnvironment[Mapping[str, Any], Mapping[str, Any]]\n</code></pre> <p>Create a modular environment from dictionaries of sensors and actuators.</p> PARAMETER DESCRIPTION <code>sensors</code> <p>A mapping of sensor names to sensor instances.</p> <p> TYPE: <code>Mapping[str, Sensor[Any]]</code> </p> <code>actuators</code> <p>A mapping of actuator names to actuator instances.</p> <p> TYPE: <code>Mapping[str, Actuator[Any]]</code> </p> RETURNS DESCRIPTION <code>ModularEnvironment[Mapping[str, Any], Mapping[str, Any]]</code> <p>A modular environment that uses composite sensors and actuators.</p> Example <pre><code>env = ModularEnvironment.from_dict(\n    sensors={\"camera\": CameraSensor(), \"lidar\": LidarSensor()},\n    actuators={\"motor\": MotorActuator(), \"gripper\": GripperActuator()}\n)\n</code></pre> Source code in <code>src/pamiq_core/interaction/modular_env.py</code> <pre><code>@staticmethod\ndef from_dict(\n    sensors: Mapping[str, Sensor[Any]], actuators: Mapping[str, Actuator[Any]]\n) -&gt; ModularEnvironment[Mapping[str, Any], Mapping[str, Any]]:\n    \"\"\"Create a modular environment from dictionaries of sensors and\n    actuators.\n\n    Args:\n        sensors: A mapping of sensor names to sensor instances.\n        actuators: A mapping of actuator names to actuator instances.\n\n    Returns:\n        A modular environment that uses composite sensors and actuators.\n\n    Example:\n        ```python\n        env = ModularEnvironment.from_dict(\n            sensors={\"camera\": CameraSensor(), \"lidar\": LidarSensor()},\n            actuators={\"motor\": MotorActuator(), \"gripper\": GripperActuator()}\n        )\n        ```\n    \"\"\"\n    return ModularEnvironment(SensorsDict(sensors), ActuatorsDict(actuators))\n</code></pre>"},{"location":"api/interaction/#pamiq_core.interaction.modular_env.SensorsDict","title":"SensorsDict","text":"<p>               Bases: <code>Sensor[Mapping[str, Any]]</code>, <code>UserDict[str, Sensor[Any]]</code></p> <p>Dictionary of sensors that acts as a composite sensor.</p> <p>This class allows grouping multiple sensors together under a single interface. When read, it returns a mapping of sensor names to their readings, providing a way to collect data from multiple sensors simultaneously.</p> <p>All lifecycle events (setup, teardown, pause, resume) and state persistence operations are propagated to all contained sensors.</p>"},{"location":"api/interaction/#pamiq_core.interaction.modular_env.SensorsDict.read","title":"read","text":"<pre><code>read() -&gt; Mapping[str, Any]\n</code></pre> <p>Read data from all contained sensors.</p> RETURNS DESCRIPTION <code>Mapping[str, Any]</code> <p>A mapping from sensor names to their respective readings.</p> Source code in <code>src/pamiq_core/interaction/modular_env.py</code> <pre><code>@override\ndef read(self) -&gt; Mapping[str, Any]:\n    \"\"\"Read data from all contained sensors.\n\n    Returns:\n        A mapping from sensor names to their respective readings.\n    \"\"\"\n    return {k: v.read() for k, v in self.items()}\n</code></pre>"},{"location":"api/interaction/#pamiq_core.interaction.modular_env.SensorsDict.setup","title":"setup","text":"<pre><code>setup() -&gt; None\n</code></pre> <p>Set up all contained sensors.</p> Source code in <code>src/pamiq_core/interaction/modular_env.py</code> <pre><code>@override\ndef setup(self) -&gt; None:\n    \"\"\"Set up all contained sensors.\"\"\"\n    super().setup()\n    for v in self.values():\n        v.setup()\n</code></pre>"},{"location":"api/interaction/#pamiq_core.interaction.modular_env.SensorsDict.teardown","title":"teardown","text":"<pre><code>teardown() -&gt; None\n</code></pre> <p>Clean up resources for all contained sensors.</p> Source code in <code>src/pamiq_core/interaction/modular_env.py</code> <pre><code>@override\ndef teardown(self) -&gt; None:\n    \"\"\"Clean up resources for all contained sensors.\"\"\"\n    super().teardown()\n    for v in self.values():\n        v.teardown()\n</code></pre>"},{"location":"api/interaction/#pamiq_core.interaction.modular_env.SensorsDict.save_state","title":"save_state","text":"<pre><code>save_state(path: Path) -&gt; None\n</code></pre> <p>Save the state of all contained sensors.</p> <p>Creates a directory at the given path and saves each sensor's state in a subdirectory named after its key in this dictionary.</p> PARAMETER DESCRIPTION <code>path</code> <p>Directory path where to save the state.</p> <p> TYPE: <code>Path</code> </p> Source code in <code>src/pamiq_core/interaction/modular_env.py</code> <pre><code>@override\ndef save_state(self, path: Path) -&gt; None:\n    \"\"\"Save the state of all contained sensors.\n\n    Creates a directory at the given path and saves each sensor's state\n    in a subdirectory named after its key in this dictionary.\n\n    Args:\n        path: Directory path where to save the state.\n    \"\"\"\n    super().save_state(path)\n    path.mkdir()\n    for k, v in self.items():\n        v.save_state(path / k)\n</code></pre>"},{"location":"api/interaction/#pamiq_core.interaction.modular_env.SensorsDict.load_state","title":"load_state","text":"<pre><code>load_state(path: Path) -&gt; None\n</code></pre> <p>Load the state of all contained sensors.</p> <p>Loads each sensor's state from a subdirectory named after its key in this dictionary.</p> PARAMETER DESCRIPTION <code>path</code> <p>Directory path from where to load the state.</p> <p> TYPE: <code>Path</code> </p> Source code in <code>src/pamiq_core/interaction/modular_env.py</code> <pre><code>@override\ndef load_state(self, path: Path) -&gt; None:\n    \"\"\"Load the state of all contained sensors.\n\n    Loads each sensor's state from a subdirectory named after its key\n    in this dictionary.\n\n    Args:\n        path: Directory path from where to load the state.\n    \"\"\"\n    super().load_state(path)\n    for k, v in self.items():\n        v.load_state(path / k)\n</code></pre>"},{"location":"api/interaction/#pamiq_core.interaction.modular_env.SensorsDict.on_paused","title":"on_paused","text":"<pre><code>on_paused() -&gt; None\n</code></pre> <p>Handle system pause event for all contained sensors.</p> Source code in <code>src/pamiq_core/interaction/modular_env.py</code> <pre><code>@override\ndef on_paused(self) -&gt; None:\n    \"\"\"Handle system pause event for all contained sensors.\"\"\"\n    super().on_paused()\n    for v in self.values():\n        v.on_paused()\n</code></pre>"},{"location":"api/interaction/#pamiq_core.interaction.modular_env.SensorsDict.on_resumed","title":"on_resumed","text":"<pre><code>on_resumed() -&gt; None\n</code></pre> <p>Handle system resume event for all contained sensors.</p> Source code in <code>src/pamiq_core/interaction/modular_env.py</code> <pre><code>@override\ndef on_resumed(self) -&gt; None:\n    \"\"\"Handle system resume event for all contained sensors.\"\"\"\n    super().on_resumed()\n    for v in self.values():\n        v.on_resumed()\n</code></pre>"},{"location":"api/interaction/#pamiq_core.interaction.modular_env.ActuatorsDict","title":"ActuatorsDict","text":"<p>               Bases: <code>Actuator[Mapping[str, Any]]</code>, <code>UserDict[str, Actuator[Any]]</code></p> <p>Dictionary of actuators that acts as a composite actuator.</p> <p>This class allows grouping multiple actuators together under a single interface. When operated, it distributes actions to individual actuators based on their keys.</p> <p>All lifecycle events (setup, teardown, pause, resume) and state persistence operations are propagated to all contained actuators.</p>"},{"location":"api/interaction/#pamiq_core.interaction.modular_env.ActuatorsDict.operate","title":"operate","text":"<pre><code>operate(action: Mapping[str, Any]) -&gt; None\n</code></pre> <p>Operate all contained actuators with their respective actions.</p> <p>Distributes the actions to the appropriate actuators based on their keys.</p> PARAMETER DESCRIPTION <code>action</code> <p>A mapping from actuator names to their respective actions.    Each action will be passed to the corresponding actuator.</p> <p> TYPE: <code>Mapping[str, Any]</code> </p> RAISES DESCRIPTION <code>KeyError</code> <p>If action doesn't contain a required actuator key.</p> Source code in <code>src/pamiq_core/interaction/modular_env.py</code> <pre><code>@override\ndef operate(self, action: Mapping[str, Any]) -&gt; None:\n    \"\"\"Operate all contained actuators with their respective actions.\n\n    Distributes the actions to the appropriate actuators based on their keys.\n\n    Args:\n        action: A mapping from actuator names to their respective actions.\n               Each action will be passed to the corresponding actuator.\n\n    Raises:\n        KeyError: If action doesn't contain a required actuator key.\n    \"\"\"\n    for k, v in self.items():\n        v.operate(action[k])\n</code></pre>"},{"location":"api/interaction/#pamiq_core.interaction.modular_env.ActuatorsDict.setup","title":"setup","text":"<pre><code>setup() -&gt; None\n</code></pre> <p>Set up all contained actuators.</p> Source code in <code>src/pamiq_core/interaction/modular_env.py</code> <pre><code>@override\ndef setup(self) -&gt; None:\n    \"\"\"Set up all contained actuators.\"\"\"\n    super().setup()\n    for v in self.values():\n        v.setup()\n</code></pre>"},{"location":"api/interaction/#pamiq_core.interaction.modular_env.ActuatorsDict.teardown","title":"teardown","text":"<pre><code>teardown() -&gt; None\n</code></pre> <p>Clean up resources for all contained actuators.</p> Source code in <code>src/pamiq_core/interaction/modular_env.py</code> <pre><code>@override\ndef teardown(self) -&gt; None:\n    \"\"\"Clean up resources for all contained actuators.\"\"\"\n    super().teardown()\n    for v in self.values():\n        v.teardown()\n</code></pre>"},{"location":"api/interaction/#pamiq_core.interaction.modular_env.ActuatorsDict.save_state","title":"save_state","text":"<pre><code>save_state(path: Path) -&gt; None\n</code></pre> <p>Save the state of all contained actuators.</p> <p>Creates a directory at the given path and saves each actuator's state in a subdirectory named after its key in this dictionary.</p> PARAMETER DESCRIPTION <code>path</code> <p>Directory path where to save the state.</p> <p> TYPE: <code>Path</code> </p> Source code in <code>src/pamiq_core/interaction/modular_env.py</code> <pre><code>@override\ndef save_state(self, path: Path) -&gt; None:\n    \"\"\"Save the state of all contained actuators.\n\n    Creates a directory at the given path and saves each actuator's state\n    in a subdirectory named after its key in this dictionary.\n\n    Args:\n        path: Directory path where to save the state.\n    \"\"\"\n    super().save_state(path)\n    path.mkdir()\n    for k, v in self.items():\n        v.save_state(path / k)\n</code></pre>"},{"location":"api/interaction/#pamiq_core.interaction.modular_env.ActuatorsDict.load_state","title":"load_state","text":"<pre><code>load_state(path: Path) -&gt; None\n</code></pre> <p>Load the state of all contained actuators.</p> <p>Loads each actuator's state from a subdirectory named after its key in this dictionary.</p> PARAMETER DESCRIPTION <code>path</code> <p>Directory path from where to load the state.</p> <p> TYPE: <code>Path</code> </p> Source code in <code>src/pamiq_core/interaction/modular_env.py</code> <pre><code>@override\ndef load_state(self, path: Path) -&gt; None:\n    \"\"\"Load the state of all contained actuators.\n\n    Loads each actuator's state from a subdirectory named after its key\n    in this dictionary.\n\n    Args:\n        path: Directory path from where to load the state.\n    \"\"\"\n    super().load_state(path)\n    for k, v in self.items():\n        v.load_state(path / k)\n</code></pre>"},{"location":"api/interaction/#pamiq_core.interaction.modular_env.ActuatorsDict.on_paused","title":"on_paused","text":"<pre><code>on_paused() -&gt; None\n</code></pre> <p>Handle system pause event for all contained actuators.</p> Source code in <code>src/pamiq_core/interaction/modular_env.py</code> <pre><code>@override\ndef on_paused(self) -&gt; None:\n    \"\"\"Handle system pause event for all contained actuators.\"\"\"\n    super().on_paused()\n    for v in self.values():\n        v.on_paused()\n</code></pre>"},{"location":"api/interaction/#pamiq_core.interaction.modular_env.ActuatorsDict.on_resumed","title":"on_resumed","text":"<pre><code>on_resumed() -&gt; None\n</code></pre> <p>Handle system resume event for all contained actuators.</p> Source code in <code>src/pamiq_core/interaction/modular_env.py</code> <pre><code>@override\ndef on_resumed(self) -&gt; None:\n    \"\"\"Handle system resume event for all contained actuators.\"\"\"\n    super().on_resumed()\n    for v in self.values():\n        v.on_resumed()\n</code></pre>"},{"location":"api/interaction/#pamiq_core.interaction.wrappers","title":"pamiq_core.interaction.wrappers","text":""},{"location":"api/interaction/#pamiq_core.interaction.wrappers.Wrapper","title":"Wrapper","text":"<p>               Bases: <code>ABC</code>, <code>InteractionEventMixin</code>, <code>PersistentStateMixin</code>, <code>ThreadEventMixin</code></p> <p>Base wrapper class for transforming values.</p> <p>This abstract class provides an interface for wrapping and transforming values from one type to another. Subclasses should implement the wrap method to define the specific transformation.</p>"},{"location":"api/interaction/#pamiq_core.interaction.wrappers.Wrapper.wrap","title":"wrap  <code>abstractmethod</code>","text":"<pre><code>wrap(value: T) -&gt; W\n</code></pre> <p>Transform the input value to another value.</p> PARAMETER DESCRIPTION <code>value</code> <p>Input value to be transformed.</p> <p> TYPE: <code>T</code> </p> RETURNS DESCRIPTION <code>W</code> <p>Transformed value.</p> Source code in <code>src/pamiq_core/interaction/wrappers.py</code> <pre><code>@abstractmethod\ndef wrap(self, value: T) -&gt; W:\n    \"\"\"Transform the input value to another value.\n\n    Args:\n        value: Input value to be transformed.\n\n    Returns:\n        Transformed value.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/interaction/#pamiq_core.interaction.wrappers.Wrapper.__call__","title":"__call__","text":"<pre><code>__call__(value: T) -&gt; W\n</code></pre> <p>Enable calling the wrapper as a function.</p> PARAMETER DESCRIPTION <code>value</code> <p>Input value to be transformed.</p> <p> TYPE: <code>T</code> </p> RETURNS DESCRIPTION <code>W</code> <p>Transformed value.</p> Source code in <code>src/pamiq_core/interaction/wrappers.py</code> <pre><code>def __call__(self, value: T) -&gt; W:\n    \"\"\"Enable calling the wrapper as a function.\n\n    Args:\n        value: Input value to be transformed.\n\n    Returns:\n        Transformed value.\n    \"\"\"\n    return self.wrap(value)\n</code></pre>"},{"location":"api/interaction/#pamiq_core.interaction.wrappers.Wrapper.wrap_sensor","title":"wrap_sensor","text":"<pre><code>wrap_sensor(sensor: Sensor[T]) -&gt; SensorWrapper[T, W]\n</code></pre> <p>Create a SensorWrapper that combines this wrapper with the provided sensor.</p> <p>This is a convenience method that applies the current wrapper to a sensor, creating a SensorWrapper that will transform the sensor's readings using this wrapper's transformation logic.</p> PARAMETER DESCRIPTION <code>sensor</code> <p>The sensor to wrap with this wrapper.</p> <p> TYPE: <code>Sensor[T]</code> </p> RETURNS DESCRIPTION <code>SensorWrapper[T, W]</code> <p>A new SensorWrapper that applies this wrapper's transformation to the sensor.</p> Source code in <code>src/pamiq_core/interaction/wrappers.py</code> <pre><code>def wrap_sensor(self, sensor: Sensor[T]) -&gt; SensorWrapper[T, W]:\n    \"\"\"Create a SensorWrapper that combines this wrapper with the provided\n    sensor.\n\n    This is a convenience method that applies the current wrapper to a sensor,\n    creating a SensorWrapper that will transform the sensor's readings using\n    this wrapper's transformation logic.\n\n    Args:\n        sensor: The sensor to wrap with this wrapper.\n\n    Returns:\n        A new SensorWrapper that applies this wrapper's transformation to the sensor.\n    \"\"\"\n    return SensorWrapper(sensor, self)\n</code></pre>"},{"location":"api/interaction/#pamiq_core.interaction.wrappers.Wrapper.wrap_actuator","title":"wrap_actuator","text":"<pre><code>wrap_actuator(actuator: Actuator[W]) -&gt; ActuatorWrapper[W, T]\n</code></pre> <p>Create an ActuatorWrapper that combines this wrapper with the provided actuator.</p> <p>This is a convenience method that applies the current wrapper to an actuator, creating an ActuatorWrapper that will transform actions before passing them to the actuator using this wrapper's transformation logic.</p> PARAMETER DESCRIPTION <code>actuator</code> <p>The actuator to wrap with this wrapper.</p> <p> TYPE: <code>Actuator[W]</code> </p> RETURNS DESCRIPTION <code>ActuatorWrapper[W, T]</code> <p>A new ActuatorWrapper that applies this wrapper's transformation to actions.</p> Source code in <code>src/pamiq_core/interaction/wrappers.py</code> <pre><code>def wrap_actuator(self, actuator: Actuator[W]) -&gt; ActuatorWrapper[W, T]:\n    \"\"\"Create an ActuatorWrapper that combines this wrapper with the\n    provided actuator.\n\n    This is a convenience method that applies the current wrapper to an actuator,\n    creating an ActuatorWrapper that will transform actions before passing them\n    to the actuator using this wrapper's transformation logic.\n\n    Args:\n        actuator: The actuator to wrap with this wrapper.\n\n    Returns:\n        A new ActuatorWrapper that applies this wrapper's transformation to actions.\n    \"\"\"\n    return ActuatorWrapper(actuator, self)\n</code></pre>"},{"location":"api/interaction/#pamiq_core.interaction.wrappers.LambdaWrapper","title":"LambdaWrapper","text":"<pre><code>LambdaWrapper(func: Callable[[T], W])\n</code></pre> <p>               Bases: <code>Wrapper[T, W]</code></p> <p>Wrapper that uses a callable function to transform values.</p> <p>This wrapper enables using lambda functions or any callable to perform the transformation.</p> <p>Initialize with a transformation function.</p> PARAMETER DESCRIPTION <code>func</code> <p>Function that transforms input values of type T to type W.</p> <p> TYPE: <code>Callable[[T], W]</code> </p> Source code in <code>src/pamiq_core/interaction/wrappers.py</code> <pre><code>def __init__(self, func: Callable[[T], W]) -&gt; None:\n    \"\"\"Initialize with a transformation function.\n\n    Args:\n        func: Function that transforms input values of type T to type W.\n    \"\"\"\n    super().__init__()\n    self._func = func\n</code></pre>"},{"location":"api/interaction/#pamiq_core.interaction.wrappers.LambdaWrapper.wrap","title":"wrap","text":"<pre><code>wrap(value: T) -&gt; W\n</code></pre> <p>Transform the value using the provided function.</p> PARAMETER DESCRIPTION <code>value</code> <p>Input value to be transformed.</p> <p> TYPE: <code>T</code> </p> RETURNS DESCRIPTION <code>W</code> <p>Transformed value.</p> Source code in <code>src/pamiq_core/interaction/wrappers.py</code> <pre><code>@override\ndef wrap(self, value: T) -&gt; W:\n    \"\"\"Transform the value using the provided function.\n\n    Args:\n        value: Input value to be transformed.\n\n    Returns:\n        Transformed value.\n    \"\"\"\n    return self._func(value)\n</code></pre>"},{"location":"api/interaction/#pamiq_core.interaction.wrappers.EnvironmentWrapper","title":"EnvironmentWrapper","text":"<pre><code>EnvironmentWrapper(\n    env: Environment[ObsType, ActType],\n    obs_wrapper: Wrapper[ObsType, WrappedObsType] | Callable[[ObsType], WrappedObsType],\n    act_wrapper: Wrapper[WrappedActType, ActType] | Callable[[WrappedActType], ActType],\n)\n</code></pre> <p>               Bases: <code>Environment[WrappedObsType, WrappedActType]</code></p> <p>Wrapper for Environment that transforms observations and actions.</p> <p>This wrapper transforms the observations returned by the wrapped environment and the actions passed to it.</p> <p>Initialize with an environment and wrappers.</p> PARAMETER DESCRIPTION <code>env</code> <p>The environment to wrap.</p> <p> TYPE: <code>Environment[ObsType, ActType]</code> </p> <code>obs_wrapper</code> <p>Wrapper for transforming observations from the environment.</p> <p> TYPE: <code>Wrapper[ObsType, WrappedObsType] | Callable[[ObsType], WrappedObsType]</code> </p> <code>act_wrapper</code> <p>Wrapper for transforming actions before passing to the environment.</p> <p> TYPE: <code>Wrapper[WrappedActType, ActType] | Callable[[WrappedActType], ActType]</code> </p> Source code in <code>src/pamiq_core/interaction/wrappers.py</code> <pre><code>def __init__(\n    self,\n    env: Environment[ObsType, ActType],\n    obs_wrapper: Wrapper[ObsType, WrappedObsType]\n    | Callable[[ObsType], WrappedObsType],\n    act_wrapper: Wrapper[WrappedActType, ActType]\n    | Callable[[WrappedActType], ActType],\n) -&gt; None:\n    \"\"\"Initialize with an environment and wrappers.\n\n    Args:\n        env: The environment to wrap.\n        obs_wrapper: Wrapper for transforming observations from the environment.\n        act_wrapper: Wrapper for transforming actions before passing to the environment.\n    \"\"\"\n    self.env = env\n    self._obs_wrapper = _ensure_wrapper(obs_wrapper)\n    self._act_wrapper = _ensure_wrapper(act_wrapper)\n</code></pre>"},{"location":"api/interaction/#pamiq_core.interaction.wrappers.EnvironmentWrapper.observe","title":"observe","text":"<pre><code>observe() -&gt; WrappedObsType\n</code></pre> <p>Get wrapped observation from the environment.</p> RETURNS DESCRIPTION <code>WrappedObsType</code> <p>Transformed observation.</p> Source code in <code>src/pamiq_core/interaction/wrappers.py</code> <pre><code>@override\ndef observe(self) -&gt; WrappedObsType:\n    \"\"\"Get wrapped observation from the environment.\n\n    Returns:\n        Transformed observation.\n    \"\"\"\n    return self._obs_wrapper(self.env.observe())\n</code></pre>"},{"location":"api/interaction/#pamiq_core.interaction.wrappers.EnvironmentWrapper.affect","title":"affect","text":"<pre><code>affect(action: WrappedActType) -&gt; None\n</code></pre> <p>Apply wrapped action to the environment.</p> PARAMETER DESCRIPTION <code>action</code> <p>Action to be transformed and applied.</p> <p> TYPE: <code>WrappedActType</code> </p> Source code in <code>src/pamiq_core/interaction/wrappers.py</code> <pre><code>@override\ndef affect(self, action: WrappedActType) -&gt; None:\n    \"\"\"Apply wrapped action to the environment.\n\n    Args:\n        action: Action to be transformed and applied.\n    \"\"\"\n    self.env.affect(self._act_wrapper(action))\n</code></pre>"},{"location":"api/interaction/#pamiq_core.interaction.wrappers.EnvironmentWrapper.setup","title":"setup","text":"<pre><code>setup() -&gt; None\n</code></pre> <p>Set up the wrapped environment and wrappers.</p> Source code in <code>src/pamiq_core/interaction/wrappers.py</code> <pre><code>@override\ndef setup(self) -&gt; None:\n    \"\"\"Set up the wrapped environment and wrappers.\"\"\"\n    self.env.setup()\n    self._obs_wrapper.setup()\n    self._act_wrapper.setup()\n</code></pre>"},{"location":"api/interaction/#pamiq_core.interaction.wrappers.EnvironmentWrapper.teardown","title":"teardown","text":"<pre><code>teardown() -&gt; None\n</code></pre> <p>Clean up the wrapped environment and wrappers.</p> Source code in <code>src/pamiq_core/interaction/wrappers.py</code> <pre><code>@override\ndef teardown(self) -&gt; None:\n    \"\"\"Clean up the wrapped environment and wrappers.\"\"\"\n    self.env.teardown()\n    self._obs_wrapper.teardown()\n    self._act_wrapper.teardown()\n</code></pre>"},{"location":"api/interaction/#pamiq_core.interaction.wrappers.EnvironmentWrapper.save_state","title":"save_state","text":"<pre><code>save_state(path: Path) -&gt; None\n</code></pre> <p>Save state of the wrapped environment and wrappers.</p> PARAMETER DESCRIPTION <code>path</code> <p>Directory path where to save the state.</p> <p> TYPE: <code>Path</code> </p> Source code in <code>src/pamiq_core/interaction/wrappers.py</code> <pre><code>@override\ndef save_state(self, path: Path) -&gt; None:\n    \"\"\"Save state of the wrapped environment and wrappers.\n\n    Args:\n        path: Directory path where to save the state.\n    \"\"\"\n    path.mkdir()\n    self.env.save_state(path / \"env\")\n    self._obs_wrapper.save_state(path / \"obs_wrapper\")\n    self._act_wrapper.save_state(path / \"act_wrapper\")\n</code></pre>"},{"location":"api/interaction/#pamiq_core.interaction.wrappers.EnvironmentWrapper.load_state","title":"load_state","text":"<pre><code>load_state(path: Path) -&gt; None\n</code></pre> <p>Load state of the wrapped environment and wrappers.</p> PARAMETER DESCRIPTION <code>path</code> <p>Directory path from where to load the state.</p> <p> TYPE: <code>Path</code> </p> Source code in <code>src/pamiq_core/interaction/wrappers.py</code> <pre><code>@override\ndef load_state(self, path: Path) -&gt; None:\n    \"\"\"Load state of the wrapped environment and wrappers.\n\n    Args:\n        path: Directory path from where to load the state.\n    \"\"\"\n    self.env.load_state(path / \"env\")\n    self._obs_wrapper.load_state(path / \"obs_wrapper\")\n    self._act_wrapper.load_state(path / \"act_wrapper\")\n</code></pre>"},{"location":"api/interaction/#pamiq_core.interaction.wrappers.EnvironmentWrapper.on_paused","title":"on_paused","text":"<pre><code>on_paused() -&gt; None\n</code></pre> <p>The method to be called when the thread is paused.</p> Source code in <code>src/pamiq_core/interaction/wrappers.py</code> <pre><code>@override\ndef on_paused(self) -&gt; None:\n    \"\"\"The method to be called when the thread is paused.\"\"\"\n    super().on_paused()\n    self.env.on_paused()\n    self._obs_wrapper.on_paused()\n    self._act_wrapper.on_paused()\n</code></pre>"},{"location":"api/interaction/#pamiq_core.interaction.wrappers.EnvironmentWrapper.on_resumed","title":"on_resumed","text":"<pre><code>on_resumed() -&gt; None\n</code></pre> <p>The method to be called when the thread is on_resumed.</p> Source code in <code>src/pamiq_core/interaction/wrappers.py</code> <pre><code>@override\ndef on_resumed(self) -&gt; None:\n    \"\"\"The method to be called when the thread is on_resumed.\"\"\"\n    super().on_resumed()\n    self.env.on_resumed()\n    self._obs_wrapper.on_resumed()\n    self._act_wrapper.on_resumed()\n</code></pre>"},{"location":"api/interaction/#pamiq_core.interaction.wrappers.SensorWrapper","title":"SensorWrapper","text":"<pre><code>SensorWrapper(sensor: Sensor[T], wrapper: Wrapper[T, W] | Callable[[T], W])\n</code></pre> <p>               Bases: <code>Sensor[W]</code></p> <p>Wrapper for Sensor that transforms sensor readings.</p> <p>This wrapper applies a transformation to the readings from the wrapped sensor.</p> <p>Initialize with a sensor and a wrapper.</p> PARAMETER DESCRIPTION <code>sensor</code> <p>The sensor to wrap.</p> <p> TYPE: <code>Sensor[T]</code> </p> <code>wrapper</code> <p>Wrapper for transforming sensor readings.</p> <p> TYPE: <code>Wrapper[T, W] | Callable[[T], W]</code> </p> Source code in <code>src/pamiq_core/interaction/wrappers.py</code> <pre><code>def __init__(\n    self, sensor: Sensor[T], wrapper: Wrapper[T, W] | Callable[[T], W]\n) -&gt; None:\n    \"\"\"Initialize with a sensor and a wrapper.\n\n    Args:\n        sensor: The sensor to wrap.\n        wrapper: Wrapper for transforming sensor readings.\n    \"\"\"\n    self.sensor = sensor\n    self._wrapper = _ensure_wrapper(wrapper)\n</code></pre>"},{"location":"api/interaction/#pamiq_core.interaction.wrappers.SensorWrapper.read","title":"read","text":"<pre><code>read() -&gt; W\n</code></pre> <p>Get transformed reading from the sensor.</p> RETURNS DESCRIPTION <code>W</code> <p>Transformed sensor reading.</p> Source code in <code>src/pamiq_core/interaction/wrappers.py</code> <pre><code>@override\ndef read(self) -&gt; W:\n    \"\"\"Get transformed reading from the sensor.\n\n    Returns:\n        Transformed sensor reading.\n    \"\"\"\n    return self._wrapper(self.sensor.read())\n</code></pre>"},{"location":"api/interaction/#pamiq_core.interaction.wrappers.SensorWrapper.setup","title":"setup","text":"<pre><code>setup() -&gt; None\n</code></pre> <p>Set up the wrapped sensor and wrapper.</p> Source code in <code>src/pamiq_core/interaction/wrappers.py</code> <pre><code>@override\ndef setup(self) -&gt; None:\n    \"\"\"Set up the wrapped sensor and wrapper.\"\"\"\n    self.sensor.setup()\n    self._wrapper.setup()\n</code></pre>"},{"location":"api/interaction/#pamiq_core.interaction.wrappers.SensorWrapper.teardown","title":"teardown","text":"<pre><code>teardown() -&gt; None\n</code></pre> <p>Clean up the wrapped sensor and wrapper.</p> Source code in <code>src/pamiq_core/interaction/wrappers.py</code> <pre><code>@override\ndef teardown(self) -&gt; None:\n    \"\"\"Clean up the wrapped sensor and wrapper.\"\"\"\n    self.sensor.teardown()\n    self._wrapper.teardown()\n</code></pre>"},{"location":"api/interaction/#pamiq_core.interaction.wrappers.SensorWrapper.save_state","title":"save_state","text":"<pre><code>save_state(path: Path) -&gt; None\n</code></pre> <p>Save state of the wrapped sensor and wrapper.</p> PARAMETER DESCRIPTION <code>path</code> <p>Directory path where to save the state.</p> <p> TYPE: <code>Path</code> </p> Source code in <code>src/pamiq_core/interaction/wrappers.py</code> <pre><code>@override\ndef save_state(self, path: Path) -&gt; None:\n    \"\"\"Save state of the wrapped sensor and wrapper.\n\n    Args:\n        path: Directory path where to save the state.\n    \"\"\"\n    path.mkdir()\n    self.sensor.save_state(path / \"sensor\")\n    self._wrapper.save_state(path / \"wrapper\")\n</code></pre>"},{"location":"api/interaction/#pamiq_core.interaction.wrappers.SensorWrapper.load_state","title":"load_state","text":"<pre><code>load_state(path: Path) -&gt; None\n</code></pre> <p>Load state of the wrapped sensor and wrapper.</p> PARAMETER DESCRIPTION <code>path</code> <p>Directory path from where to load the state.</p> <p> TYPE: <code>Path</code> </p> Source code in <code>src/pamiq_core/interaction/wrappers.py</code> <pre><code>@override\ndef load_state(self, path: Path) -&gt; None:\n    \"\"\"Load state of the wrapped sensor and wrapper.\n\n    Args:\n        path: Directory path from where to load the state.\n    \"\"\"\n    self.sensor.load_state(path / \"sensor\")\n    self._wrapper.load_state(path / \"wrapper\")\n</code></pre>"},{"location":"api/interaction/#pamiq_core.interaction.wrappers.SensorWrapper.on_paused","title":"on_paused","text":"<pre><code>on_paused() -&gt; None\n</code></pre> <p>The method to be called when the thread is paused.</p> Source code in <code>src/pamiq_core/interaction/wrappers.py</code> <pre><code>@override\ndef on_paused(self) -&gt; None:\n    \"\"\"The method to be called when the thread is paused.\"\"\"\n    super().on_paused()\n    self.sensor.on_paused()\n    self._wrapper.on_paused()\n</code></pre>"},{"location":"api/interaction/#pamiq_core.interaction.wrappers.SensorWrapper.on_resumed","title":"on_resumed","text":"<pre><code>on_resumed() -&gt; None\n</code></pre> <p>The method to be called when the thread is resumed.</p> Source code in <code>src/pamiq_core/interaction/wrappers.py</code> <pre><code>@override\ndef on_resumed(self) -&gt; None:\n    \"\"\"The method to be called when the thread is resumed.\"\"\"\n    super().on_resumed()\n    self.sensor.on_resumed()\n    self._wrapper.on_resumed()\n</code></pre>"},{"location":"api/interaction/#pamiq_core.interaction.wrappers.ActuatorWrapper","title":"ActuatorWrapper","text":"<pre><code>ActuatorWrapper(actuator: Actuator[T], wrapper: Wrapper[W, T] | Callable[[W], T])\n</code></pre> <p>               Bases: <code>Actuator[W]</code></p> <p>Wrapper for Actuator that transforms actions.</p> <p>This wrapper applies a transformation to actions before passing them to the wrapped actuator.</p> <p>Initialize with an actuator and a wrapper.</p> PARAMETER DESCRIPTION <code>actuator</code> <p>The actuator to wrap.</p> <p> TYPE: <code>Actuator[T]</code> </p> <code>wrapper</code> <p>Wrapper for transforming actions.</p> <p> TYPE: <code>Wrapper[W, T] | Callable[[W], T]</code> </p> Source code in <code>src/pamiq_core/interaction/wrappers.py</code> <pre><code>def __init__(\n    self, actuator: Actuator[T], wrapper: Wrapper[W, T] | Callable[[W], T]\n) -&gt; None:\n    \"\"\"Initialize with an actuator and a wrapper.\n\n    Args:\n        actuator: The actuator to wrap.\n        wrapper: Wrapper for transforming actions.\n    \"\"\"\n    self.actuator = actuator\n    self._wrapper = _ensure_wrapper(wrapper)\n</code></pre>"},{"location":"api/interaction/#pamiq_core.interaction.wrappers.ActuatorWrapper.operate","title":"operate","text":"<pre><code>operate(action: W) -&gt; None\n</code></pre> <p>Apply transformed action to the actuator.</p> PARAMETER DESCRIPTION <code>action</code> <p>Action to be transformed and applied.</p> <p> TYPE: <code>W</code> </p> Source code in <code>src/pamiq_core/interaction/wrappers.py</code> <pre><code>@override\ndef operate(self, action: W) -&gt; None:\n    \"\"\"Apply transformed action to the actuator.\n\n    Args:\n        action: Action to be transformed and applied.\n    \"\"\"\n    self.actuator.operate(self._wrapper(action))\n</code></pre>"},{"location":"api/interaction/#pamiq_core.interaction.wrappers.ActuatorWrapper.setup","title":"setup","text":"<pre><code>setup() -&gt; None\n</code></pre> <p>Set up the wrapped actuator and wrapper.</p> Source code in <code>src/pamiq_core/interaction/wrappers.py</code> <pre><code>@override\ndef setup(self) -&gt; None:\n    \"\"\"Set up the wrapped actuator and wrapper.\"\"\"\n    self.actuator.setup()\n    self._wrapper.setup()\n</code></pre>"},{"location":"api/interaction/#pamiq_core.interaction.wrappers.ActuatorWrapper.teardown","title":"teardown","text":"<pre><code>teardown() -&gt; None\n</code></pre> <p>Clean up the wrapped actuator and wrapper.</p> Source code in <code>src/pamiq_core/interaction/wrappers.py</code> <pre><code>@override\ndef teardown(self) -&gt; None:\n    \"\"\"Clean up the wrapped actuator and wrapper.\"\"\"\n    self.actuator.teardown()\n    self._wrapper.teardown()\n</code></pre>"},{"location":"api/interaction/#pamiq_core.interaction.wrappers.ActuatorWrapper.save_state","title":"save_state","text":"<pre><code>save_state(path: Path) -&gt; None\n</code></pre> <p>Save state of the wrapped actuator and wrapper.</p> PARAMETER DESCRIPTION <code>path</code> <p>Directory path where to save the state.</p> <p> TYPE: <code>Path</code> </p> Source code in <code>src/pamiq_core/interaction/wrappers.py</code> <pre><code>@override\ndef save_state(self, path: Path) -&gt; None:\n    \"\"\"Save state of the wrapped actuator and wrapper.\n\n    Args:\n        path: Directory path where to save the state.\n    \"\"\"\n    path.mkdir()\n    self.actuator.save_state(path / \"actuator\")\n    self._wrapper.save_state(path / \"wrapper\")\n</code></pre>"},{"location":"api/interaction/#pamiq_core.interaction.wrappers.ActuatorWrapper.load_state","title":"load_state","text":"<pre><code>load_state(path: Path) -&gt; None\n</code></pre> <p>Load state of the wrapped actuator and wrapper.</p> PARAMETER DESCRIPTION <code>path</code> <p>Directory path from where to load the state.</p> <p> TYPE: <code>Path</code> </p> Source code in <code>src/pamiq_core/interaction/wrappers.py</code> <pre><code>@override\ndef load_state(self, path: Path) -&gt; None:\n    \"\"\"Load state of the wrapped actuator and wrapper.\n\n    Args:\n        path: Directory path from where to load the state.\n    \"\"\"\n    self.actuator.load_state(path / \"actuator\")\n    self._wrapper.load_state(path / \"wrapper\")\n</code></pre>"},{"location":"api/interaction/#pamiq_core.interaction.wrappers.ActuatorWrapper.on_paused","title":"on_paused","text":"<pre><code>on_paused() -&gt; None\n</code></pre> <p>The method to be called when the thread is paused.</p> Source code in <code>src/pamiq_core/interaction/wrappers.py</code> <pre><code>@override\ndef on_paused(self) -&gt; None:\n    \"\"\"The method to be called when the thread is paused.\"\"\"\n    super().on_paused()\n    self.actuator.on_paused()\n    self._wrapper.on_paused()\n</code></pre>"},{"location":"api/interaction/#pamiq_core.interaction.wrappers.ActuatorWrapper.on_resumed","title":"on_resumed","text":"<pre><code>on_resumed() -&gt; None\n</code></pre> <p>The method to be called when the thread is resumed.</p> Source code in <code>src/pamiq_core/interaction/wrappers.py</code> <pre><code>@override\ndef on_resumed(self) -&gt; None:\n    \"\"\"The method to be called when the thread is resumed.\"\"\"\n    super().on_resumed()\n    self.actuator.on_resumed()\n    self._wrapper.on_resumed()\n</code></pre>"},{"location":"api/launch/","title":"Launch","text":""},{"location":"api/launch/#pamiq_core.launcher.LaunchConfig","title":"pamiq_core.launcher.LaunchConfig  <code>dataclass</code>","text":"<pre><code>LaunchConfig(\n    states_dir: str | Path = Path(\"./states\"),\n    state_name_format: str = \"%Y-%m-%d_%H-%M-%S,%f.state\",\n    saved_state_path: str | Path | None = None,\n    save_state_interval: float = float(\"inf\"),\n    max_keep_states: int = -1,\n    state_name_pattern: str = \"*.state\",\n    states_cleanup_interval: float = 60.0,\n    timeout_for_all_threads_pause: float = 60.0,\n    max_attempts_to_pause_all_threads: int = 3,\n    max_uptime: float = float(\"inf\"),\n    web_api_address: tuple[str, int] = (\"localhost\", 8319),\n    web_api_command_queue_size: int = 1,\n    log_tick_time_statistics_interval: float = 60.0,\n    time_scale: float = 1.0,\n)\n</code></pre> <p>Configuration parameters for system launch.</p> <p>This class encapsulates all configuration parameters needed to launch the AMI system. It controls thread behavior, state persistence, API settings, timing, and other critical system parameters.</p> ATTRIBUTE DESCRIPTION <code>states_dir</code> <p>Directory path where states will be saved.</p> <p> TYPE: <code>str | Path</code> </p> <code>state_name_format</code> <p>Format string for state directory names.</p> <p> TYPE: <code>str</code> </p> <code>saved_state_path</code> <p>Optional path to a previously saved state to load at startup.</p> <p> TYPE: <code>str | Path | None</code> </p> <code>save_state_interval</code> <p>Interval in seconds between automatic state saves. Use infinity for no automatic saves.</p> <p> TYPE: <code>float</code> </p> <code>max_keep_states</code> <p>Maximum number of state directories to keep in the states directory. Older state directories beyond this number will be automatically removed. Use -1 to disable this feature (no automatic removal).</p> <p> TYPE: <code>int</code> </p> <code>state_name_pattern</code> <p>Glob pattern to identify state directories for management.</p> <p> TYPE: <code>str</code> </p> <code>states_cleanup_interval</code> <p>Interval in seconds between automatic state cleanup.</p> <p> TYPE: <code>float</code> </p> <code>timeout_for_all_threads_pause</code> <p>Maximum time in seconds to wait for all threads to pause before timing out.</p> <p> TYPE: <code>float</code> </p> <code>max_attempts_to_pause_all_threads</code> <p>Maximum number of retry attempts when pausing threads fails.</p> <p> TYPE: <code>int</code> </p> <code>max_uptime</code> <p>Maximum time in seconds the system is allowed to run. Use infinity for no time limit.</p> <p> TYPE: <code>float</code> </p> <code>web_api_address</code> <p>Tuple of (host, port) for the web API server.</p> <p> TYPE: <code>tuple[str, int]</code> </p> <code>web_api_command_queue_size</code> <p>Maximum size of the command queue for the web API.</p> <p> TYPE: <code>int</code> </p> <code>log_tick_time_statistics_interval</code> <p>Interval in seconds for logging step time statistics in inference thread.</p> <p> TYPE: <code>float</code> </p> <code>time_scale</code> <p>Scale factor for system time, affecting the speed of time passage.</p> <p> TYPE: <code>float</code> </p>"},{"location":"api/launch/#pamiq_core.launcher.launch","title":"pamiq_core.launcher.launch","text":"<pre><code>launch(\n    interaction: Interaction[Any, Any],\n    models: Mapping[str, TrainingModel[Any]],\n    data: Mapping[str, DataBuffer[Any]],\n    trainers: Mapping[str, Trainer],\n    config: Mapping[str, Any] | LaunchConfig | None = None,\n) -&gt; None\n</code></pre> <p>Launch the AMI system with specified components and configuration.</p> <p>This function is the main entry point for starting the AMI system. It initializes and connects all system components, sets up the multi-threading architecture, and starts the control, inference, and training threads.</p> <p>The function will run until the system is shut down or interrupted. Once complete, it will save the final system state before exiting.</p> PARAMETER DESCRIPTION <code>interaction</code> <p>Agent-environment interaction procedure.</p> <p> TYPE: <code>Interaction[Any, Any]</code> </p> <code>models</code> <p>Dictionary mapping names to training models.</p> <p> TYPE: <code>Mapping[str, TrainingModel[Any]]</code> </p> <code>data</code> <p>Dictionary mapping names to data buffers.</p> <p> TYPE: <code>Mapping[str, DataBuffer[Any]]</code> </p> <code>trainers</code> <p>Dictionary mapping names to trainers.</p> <p> TYPE: <code>Mapping[str, Trainer]</code> </p> <code>config</code> <p>Configuration parameters, either as a LaunchConfig instance or a dictionary of parameter values. If None, default configuration is used.</p> <p> TYPE: <code>Mapping[str, Any] | LaunchConfig | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/pamiq_core/launcher.py</code> <pre><code>def launch(\n    interaction: Interaction[Any, Any],\n    models: Mapping[str, TrainingModel[Any]],\n    data: Mapping[str, DataBuffer[Any]],\n    trainers: Mapping[str, Trainer],\n    config: Mapping[str, Any] | LaunchConfig | None = None,\n) -&gt; None:\n    \"\"\"Launch the AMI system with specified components and configuration.\n\n    This function is the main entry point for starting the AMI system. It initializes\n    and connects all system components, sets up the multi-threading architecture,\n    and starts the control, inference, and training threads.\n\n    The function will run until the system is shut down or interrupted. Once complete,\n    it will save the final system state before exiting.\n\n    Args:\n        interaction: Agent-environment interaction procedure.\n        models: Dictionary mapping names to training models.\n        data: Dictionary mapping names to data buffers.\n        trainers: Dictionary mapping names to trainers.\n        config: Configuration parameters, either as a LaunchConfig instance\n            or a dictionary of parameter values. If None, default configuration\n            is used.\n    \"\"\"\n    logger = logging.getLogger(__name__)\n\n    # Initialize configuration\n    if config is None:\n        config = {}\n    if not isinstance(config, LaunchConfig):\n        config = LaunchConfig(**config)\n\n    # Initialize system components with proper containers\n    training_models = TrainingModelsDict(models)\n    data_users = DataUsersDict.from_data_buffers(data)\n    trainers_dict = TrainersDict(trainers)\n\n    interaction.agent.attach_inference_models(training_models.inference_models_dict)\n    interaction.agent.attach_data_collectors(data_users.data_collectors_dict)\n\n    trainers_dict.attach_training_models(training_models)\n    trainers_dict.attach_data_users(data_users)\n\n    # Set up state persistence\n    logger.info(f\"Setting up state persistence in directory: {config.states_dir}\")\n    state_store = StateStore(config.states_dir, config.state_name_format)\n    state_store.register(\"interaction\", interaction)\n    state_store.register(\"models\", training_models)\n    state_store.register(\"data\", data_users)\n    state_store.register(\"trainers\", trainers_dict)\n    state_store.register(\"time\", time.get_global_time_controller())\n\n    states_keeper = LatestStatesKeeper(\n        states_dir=config.states_dir,\n        state_name_pattern=config.state_name_pattern,\n        max_keep=config.max_keep_states,\n        cleanup_interval=config.states_cleanup_interval,\n    )\n\n    # Load state if specified\n    if config.saved_state_path is not None:\n        logger.info(f\"Loading state from '{config.saved_state_path}'\")\n        state_store.load_state(config.saved_state_path)\n\n    # Initialize threads\n    control_thread = ControlThread(\n        state_store,\n        save_state_interval=config.save_state_interval,\n        timeout_for_all_threads_pause=config.timeout_for_all_threads_pause,\n        max_attempts_to_pause_all_threads=config.max_attempts_to_pause_all_threads,\n        max_uptime=config.max_uptime,\n        web_api_address=config.web_api_address,\n        web_api_command_queue_size=config.web_api_command_queue_size,\n    )\n    inference_thread = InferenceThread(\n        interaction,\n        log_tick_time_statistics_interval=config.log_tick_time_statistics_interval,\n    )\n    training_thread = TrainingThread(trainers_dict)\n\n    # Connect threads\n    for thread in [inference_thread, training_thread]:\n        thread.attach_controller(control_thread.controller)\n\n    control_thread.attach_thread_statuses(\n        {t.THREAD_TYPE: t.thread_status for t in [inference_thread, training_thread]}\n    )\n\n    # Launch the system\n    logger.info(\"Launching AMI system...\")\n\n    try:\n        logger.info(f\"Setting time scale to {config.time_scale}\")\n        time.set_time_scale(config.time_scale)\n\n        states_keeper.start()\n\n        inference_thread.start()\n        training_thread.start()\n        control_thread.run()  # Blocking until shutdown or KeyboardInterrupt\n    except KeyboardInterrupt:\n        logger.info(\"Keyboard Interrupt detected, shutting down system\")\n    except Exception as e:\n        logger.error(f\"Error during system execution: {e}\", exc_info=True)\n        raise\n    finally:\n        inference_thread.join()\n        training_thread.join()\n        time.set_time_scale(1.0)  # Fix time scale.\n\n        logger.info(\"Saving final system state\")\n        state_path = state_store.save_state()\n        logger.info(f\"Final state saved to '{state_path}'\")\n\n        states_keeper.stop()\n        states_keeper.cleanup()\n</code></pre>"},{"location":"api/model/","title":"Model","text":""},{"location":"api/model/#pamiq_core.model.InferenceModel","title":"pamiq_core.model.InferenceModel","text":"<p>               Bases: <code>ABC</code></p> <p>Base interface class for model to infer in InferenceThread.</p> <p>Needed for multi-thread training and inference in parallel.</p>"},{"location":"api/model/#pamiq_core.model.InferenceModel.infer","title":"infer  <code>abstractmethod</code>","text":"<pre><code>infer(*args: Any, **kwds: Any) -&gt; Any\n</code></pre> <p>Perform inference using a model.</p> PARAMETER DESCRIPTION <code>*args</code> <p>Positional arguments required for inference.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>()</code> </p> <code>**kwds</code> <p>Keyword arguments required for inference.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> <p>Returns:     Any: The result of the inference.</p> Source code in <code>src/pamiq_core/model/interface.py</code> <pre><code>@abstractmethod\ndef infer(self, *args: Any, **kwds: Any) -&gt; Any:\n    \"\"\"Perform inference using a model.\n\n    Args:\n        *args: Positional arguments required for inference.\n        **kwds: Keyword arguments required for inference.\n    Returns:\n        Any: The result of the inference.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api/model/#pamiq_core.model.InferenceModel.__call__","title":"__call__","text":"<pre><code>__call__(*args: Any, **kwds: Any) -&gt; Any\n</code></pre> <p>Perform inference using a model.</p> PARAMETER DESCRIPTION <code>*args</code> <p>Positional arguments required for inference.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>()</code> </p> <code>**kwds</code> <p>Keyword arguments required for inference.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> <p>Returns:     Any: The result of the inference.</p> Source code in <code>src/pamiq_core/model/interface.py</code> <pre><code>def __call__(self, *args: Any, **kwds: Any) -&gt; Any:\n    \"\"\"Perform inference using a model.\n\n    Args:\n        *args:  Positional arguments required for inference.\n        **kwds: Keyword arguments required for inference.\n    Returns:\n        Any: The result of the inference.\n    \"\"\"\n    return self.infer(*args, **kwds)\n</code></pre>"},{"location":"api/model/#pamiq_core.model.TrainingModel","title":"pamiq_core.model.TrainingModel","text":"<pre><code>TrainingModel(has_inference_model: bool = True, inference_thread_only: bool = False)\n</code></pre> <p>               Bases: <code>ABC</code>, <code>PersistentStateMixin</code></p> <p>Base interface class to train model in TrainingThread.</p> <p>Needed for multi-thread training and inference in parallel.</p> <p>Initialize the TrainingModel.</p> PARAMETER DESCRIPTION <code>has_inference_model</code> <p>Whether to have inference model.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>inference_thread_only</code> <p>Whether it is an inference thread only.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>src/pamiq_core/model/interface.py</code> <pre><code>def __init__(\n    self, has_inference_model: bool = True, inference_thread_only: bool = False\n):\n    \"\"\"Initialize the TrainingModel.\n\n    Args:\n        has_inference_model: Whether to have inference model.\n        inference_thread_only: Whether it is an inference thread only.\n    \"\"\"\n    if (not has_inference_model) and (inference_thread_only):\n        raise ValueError\n    self.has_inference_model = has_inference_model\n    self.inference_thread_only = inference_thread_only\n</code></pre>"},{"location":"api/model/#pamiq_core.model.TrainingModel.inference_model","title":"inference_model  <code>property</code>","text":"<pre><code>inference_model: T\n</code></pre> <p>Get inference model.</p>"},{"location":"api/model/#pamiq_core.model.TrainingModel.forward","title":"forward  <code>abstractmethod</code>","text":"<pre><code>forward(*args: Any, **kwds: Any) -&gt; Any\n</code></pre> <p>Forward path of model.</p> PARAMETER DESCRIPTION <code>*args</code> <p>Positional arguments required for forward path.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>()</code> </p> <code>**kwds</code> <p>Keyword arguments required for forward path.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> <p>Returns:     Result of forward path of the model.</p> Source code in <code>src/pamiq_core/model/interface.py</code> <pre><code>@abstractmethod\ndef forward(self, *args: Any, **kwds: Any) -&gt; Any:\n    \"\"\"Forward path of model.\n\n    Args:\n        *args: Positional arguments required for forward path.\n        **kwds: Keyword arguments required for forward path.\n    Returns:\n        Result of forward path of the model.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/model/#pamiq_core.model.TrainingModel.__call__","title":"__call__","text":"<pre><code>__call__(*args: Any, **kwds: Any) -&gt; Any\n</code></pre> <p>Calls <code>forward</code> method.</p> Source code in <code>src/pamiq_core/model/interface.py</code> <pre><code>def __call__(self, *args: Any, **kwds: Any) -&gt; Any:\n    \"\"\"Calls `forward` method.\"\"\"\n    return self.forward(*args, **kwds)\n</code></pre>"},{"location":"api/model/#pamiq_core.model.TrainingModel.sync","title":"sync","text":"<pre><code>sync() -&gt; None\n</code></pre> <p>Synchronizes parameters of training model to self._inference_model if needed.</p> Source code in <code>src/pamiq_core/model/interface.py</code> <pre><code>def sync(self) -&gt; None:\n    \"\"\"Synchronizes parameters of training model to self._inference_model\n    if needed.\"\"\"\n    if self._need_sync:\n        self.sync_impl(self.inference_model)\n</code></pre>"},{"location":"api/model/#pamiq_core.model.TrainingModel.sync_impl","title":"sync_impl  <code>abstractmethod</code>","text":"<pre><code>sync_impl(inference_model: T) -&gt; None\n</code></pre> <p>Copies params of training model to self._inference_model if needed.</p> PARAMETER DESCRIPTION <code>inference_model</code> <p>InferenceModel to sync.</p> <p> TYPE: <code>T</code> </p> Source code in <code>src/pamiq_core/model/interface.py</code> <pre><code>@abstractmethod\ndef sync_impl(self, inference_model: T) -&gt; None:\n    \"\"\"Copies params of training model to self._inference_model if needed.\n\n    Args:\n        inference_model: InferenceModel to sync.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/schedulers/","title":"Schedulers","text":""},{"location":"api/schedulers/#pamiq_core.utils.schedulers.Scheduler","title":"pamiq_core.utils.schedulers.Scheduler","text":"<pre><code>Scheduler(callbacks: Callback | CallbackIterable | None = None)\n</code></pre> <p>               Bases: <code>ABC</code></p> <p>Abstract base class for schedulers.</p> <p>Schedulers periodically execute registered callbacks based on specific conditions defined by subclasses. The base class provides functionality for managing callbacks.</p> <p>Initialize the scheduler.</p> PARAMETER DESCRIPTION <code>callbacks</code> <p>Optional iterable of callback functions to register or callback.</p> <p> TYPE: <code>Callback | CallbackIterable | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/pamiq_core/utils/schedulers.py</code> <pre><code>def __init__(self, callbacks: Callback | CallbackIterable | None = None) -&gt; None:\n    \"\"\"Initialize the scheduler.\n\n    Args:\n        callbacks: Optional iterable of callback functions to register or callback.\n    \"\"\"\n    if callbacks is None:\n        callbacks = []\n    if isinstance(callbacks, Callable):\n        callbacks = [callbacks]\n\n    self._callbacks = list(callbacks)\n</code></pre>"},{"location":"api/schedulers/#pamiq_core.utils.schedulers.Scheduler.register_callback","title":"register_callback","text":"<pre><code>register_callback(callback: Callback) -&gt; None\n</code></pre> <p>Register a new callback function.</p> PARAMETER DESCRIPTION <code>callback</code> <p>The callback function to register.</p> <p> TYPE: <code>Callback</code> </p> Source code in <code>src/pamiq_core/utils/schedulers.py</code> <pre><code>def register_callback(self, callback: Callback) -&gt; None:\n    \"\"\"Register a new callback function.\n\n    Args:\n        callback: The callback function to register.\n    \"\"\"\n    self._callbacks.append(callback)\n</code></pre>"},{"location":"api/schedulers/#pamiq_core.utils.schedulers.Scheduler.remove_callback","title":"remove_callback","text":"<pre><code>remove_callback(callback: Callback) -&gt; None\n</code></pre> <p>Remove a registered callback function.</p> PARAMETER DESCRIPTION <code>callback</code> <p>The callback function to remove.</p> <p> TYPE: <code>Callback</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If the callback is not registered.</p> Source code in <code>src/pamiq_core/utils/schedulers.py</code> <pre><code>def remove_callback(self, callback: Callback) -&gt; None:\n    \"\"\"Remove a registered callback function.\n\n    Args:\n        callback: The callback function to remove.\n\n    Raises:\n        ValueError: If the callback is not registered.\n    \"\"\"\n    self._callbacks.remove(callback)\n</code></pre>"},{"location":"api/schedulers/#pamiq_core.utils.schedulers.Scheduler.is_available","title":"is_available  <code>abstractmethod</code>","text":"<pre><code>is_available() -&gt; bool\n</code></pre> <p>Check if the scheduler should execute callbacks now.</p> RETURNS DESCRIPTION <code>bool</code> <p>True if callbacks should be executed, False otherwise.</p> Source code in <code>src/pamiq_core/utils/schedulers.py</code> <pre><code>@abstractmethod\ndef is_available(self) -&gt; bool:\n    \"\"\"Check if the scheduler should execute callbacks now.\n\n    Returns:\n        True if callbacks should be executed, False otherwise.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/schedulers/#pamiq_core.utils.schedulers.Scheduler.update","title":"update  <code>abstractmethod</code>","text":"<pre><code>update() -&gt; None\n</code></pre> <p>Check if callbacks should be executed and run them if so.</p> <p>This method should be called regularly to check if execution conditions are met.</p> Source code in <code>src/pamiq_core/utils/schedulers.py</code> <pre><code>@abstractmethod\ndef update(self) -&gt; None:\n    \"\"\"Check if callbacks should be executed and run them if so.\n\n    This method should be called regularly to check if execution\n    conditions are met.\n    \"\"\"\n    if self.is_available():\n        for callback in self._callbacks:\n            callback()\n</code></pre>"},{"location":"api/schedulers/#pamiq_core.utils.schedulers.TimeIntervalScheduler","title":"pamiq_core.utils.schedulers.TimeIntervalScheduler","text":"<pre><code>TimeIntervalScheduler(\n    interval: float, callbacks: Callback | CallbackIterable | None = None\n)\n</code></pre> <p>               Bases: <code>Scheduler</code></p> <p>Scheduler that executes callbacks at specified time intervals.</p> <p>This scheduler triggers callbacks when a specified amount of time has elapsed since the last execution.</p> <p>Initialize the time interval scheduler.</p> PARAMETER DESCRIPTION <code>interval</code> <p>Time interval in seconds between executions.</p> <p> TYPE: <code>float</code> </p> <code>callbacks</code> <p>Optional iterable of callback functions to register.</p> <p> TYPE: <code>Callback | CallbackIterable | None</code> DEFAULT: <code>None</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If interval is negative.</p> Source code in <code>src/pamiq_core/utils/schedulers.py</code> <pre><code>@override\ndef __init__(\n    self, interval: float, callbacks: Callback | CallbackIterable | None = None\n) -&gt; None:\n    \"\"\"Initialize the time interval scheduler.\n\n    Args:\n        interval: Time interval in seconds between executions.\n        callbacks: Optional iterable of callback functions to register.\n\n    Raises:\n        ValueError: If interval is negative.\n    \"\"\"\n    super().__init__(callbacks)\n    if interval &lt; 0:\n        raise ValueError(\"Interval must be non-negative\")\n    self._interval = interval\n    self._previous_available_time = float(\"-inf\")\n</code></pre>"},{"location":"api/schedulers/#pamiq_core.utils.schedulers.TimeIntervalScheduler.is_available","title":"is_available","text":"<pre><code>is_available() -&gt; bool\n</code></pre> <p>Check if the specified time interval has elapsed.</p> RETURNS DESCRIPTION <code>bool</code> <p>True if the time interval has elapsed, False otherwise.</p> Source code in <code>src/pamiq_core/utils/schedulers.py</code> <pre><code>@override\ndef is_available(self) -&gt; bool:\n    \"\"\"Check if the specified time interval has elapsed.\n\n    Returns:\n        True if the time interval has elapsed, False otherwise.\n    \"\"\"\n    return time.time() - self._previous_available_time &gt; self._interval\n</code></pre>"},{"location":"api/schedulers/#pamiq_core.utils.schedulers.TimeIntervalScheduler.update","title":"update","text":"<pre><code>update() -&gt; None\n</code></pre> <p>Check if the time interval has elapsed and execute callbacks if so.</p> <p>Updates the previous execution time after callbacks are executed.</p> Source code in <code>src/pamiq_core/utils/schedulers.py</code> <pre><code>@override\ndef update(self) -&gt; None:\n    \"\"\"Check if the time interval has elapsed and execute callbacks if so.\n\n    Updates the previous execution time after callbacks are\n    executed.\n    \"\"\"\n    super().update()  # Call parent to execute callbacks if available\n    if self.is_available():\n        self._previous_available_time = time.time()\n</code></pre>"},{"location":"api/schedulers/#pamiq_core.utils.schedulers.StepIntervalScheduler","title":"pamiq_core.utils.schedulers.StepIntervalScheduler","text":"<pre><code>StepIntervalScheduler(\n    interval: int, callbacks: Callback | CallbackIterable | None = None\n)\n</code></pre> <p>               Bases: <code>Scheduler</code></p> <p>Scheduler that executes callbacks after a specified number of steps.</p> <p>This scheduler triggers callbacks when a specified number of steps have been completed since the last execution.</p> <p>Initialize the step interval scheduler.</p> PARAMETER DESCRIPTION <code>interval</code> <p>Number of steps between executions.</p> <p> TYPE: <code>int</code> </p> <code>callbacks</code> <p>Optional iterable of callback functions to register.</p> <p> TYPE: <code>Callback | CallbackIterable | None</code> DEFAULT: <code>None</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If interval is not positive.</p> Source code in <code>src/pamiq_core/utils/schedulers.py</code> <pre><code>@override\ndef __init__(\n    self, interval: int, callbacks: Callback | CallbackIterable | None = None\n) -&gt; None:\n    \"\"\"Initialize the step interval scheduler.\n\n    Args:\n        interval: Number of steps between executions.\n        callbacks: Optional iterable of callback functions to register.\n\n    Raises:\n        ValueError: If interval is not positive.\n    \"\"\"\n    super().__init__(callbacks)\n    if interval &lt;= 0:\n        raise ValueError(\"Interval must be positive\")\n    self._interval = interval\n    self._steps_since_last_call = 0\n</code></pre>"},{"location":"api/schedulers/#pamiq_core.utils.schedulers.StepIntervalScheduler.is_available","title":"is_available","text":"<pre><code>is_available() -&gt; bool\n</code></pre> <p>Check if the specified number of steps has been reached.</p> RETURNS DESCRIPTION <code>bool</code> <p>True if the step interval has been reached, False otherwise.</p> Source code in <code>src/pamiq_core/utils/schedulers.py</code> <pre><code>@override\ndef is_available(self) -&gt; bool:\n    \"\"\"Check if the specified number of steps has been reached.\n\n    Returns:\n        True if the step interval has been reached, False otherwise.\n    \"\"\"\n    return self._steps_since_last_call &gt;= self._interval\n</code></pre>"},{"location":"api/schedulers/#pamiq_core.utils.schedulers.StepIntervalScheduler.update","title":"update","text":"<pre><code>update() -&gt; None\n</code></pre> <p>Increment step counter, execute callbacks if interval is reached.</p> <p>Resets the step counter after callbacks are executed.</p> Source code in <code>src/pamiq_core/utils/schedulers.py</code> <pre><code>@override\ndef update(self) -&gt; None:\n    \"\"\"Increment step counter, execute callbacks if interval is reached.\n\n    Resets the step counter after callbacks are executed.\n    \"\"\"\n    self._steps_since_last_call += 1\n    super().update()  # Call parent to execute callbacks if available\n    if self.is_available():\n        self._steps_since_last_call = 0\n</code></pre>"},{"location":"api/state_persistence/","title":"State Persistence","text":""},{"location":"api/state_persistence/#pamiq_core.state_persistence.PersistentStateMixin","title":"pamiq_core.state_persistence.PersistentStateMixin","text":"<p>Mixin class for objects with persistable state.</p> <p>This mixin provides the ability to save and load state. Classes that inherit from this mixin must implement <code>save_state()</code> and <code>load_state()</code>.</p>"},{"location":"api/state_persistence/#pamiq_core.state_persistence.PersistentStateMixin.save_state","title":"save_state","text":"<pre><code>save_state(path: Path)\n</code></pre> <p>Save state to <code>path</code></p> Source code in <code>src/pamiq_core/state_persistence.py</code> <pre><code>def save_state(self, path: Path):\n    \"\"\"Save state to `path`\"\"\"\n    pass\n</code></pre>"},{"location":"api/state_persistence/#pamiq_core.state_persistence.PersistentStateMixin.load_state","title":"load_state","text":"<pre><code>load_state(path: Path)\n</code></pre> <p>Load state from <code>path</code></p> Source code in <code>src/pamiq_core/state_persistence.py</code> <pre><code>def load_state(self, path: Path):\n    \"\"\"Load state from `path`\"\"\"\n    pass\n</code></pre>"},{"location":"api/state_persistence/#pamiq_core.state_persistence.StateStore","title":"pamiq_core.state_persistence.StateStore","text":"<pre><code>StateStore(\n    states_dir: str | Path, state_name_format: str = \"%Y-%m-%d_%H-%M-%S,%f.state\"\n)\n</code></pre> <p>Class to save and load multiple persistable objects at once.</p> <p>This class saves the state of each registered object to the specified directory. It is also possible to restore the state from the directory.</p> PARAMETER DESCRIPTION <code>states_dir</code> <p>Root path to the directory where states are saved</p> <p> TYPE: <code>str | Path</code> </p> <code>state_name_format</code> <p>Format for the subdirectory name (defaults to timestamp)</p> <p> TYPE: <code>str</code> DEFAULT: <code>'%Y-%m-%d_%H-%M-%S,%f.state'</code> </p> Source code in <code>src/pamiq_core/state_persistence.py</code> <pre><code>def __init__(\n    self,\n    states_dir: str | Path,\n    state_name_format: str = \"%Y-%m-%d_%H-%M-%S,%f.state\",\n) -&gt; None:\n    \"\"\"\n    Args:\n        states_dir: Root path to the directory where states are saved\n        state_name_format: Format for the subdirectory name (defaults to timestamp)\n    \"\"\"\n    self.states_dir = Path(states_dir)\n    self.states_dir.mkdir(exist_ok=True)\n    self.state_name_format = state_name_format\n    self._registered_states: dict[str, PersistentStateMixin] = {}\n</code></pre>"},{"location":"api/state_persistence/#pamiq_core.state_persistence.StateStore.register","title":"register","text":"<pre><code>register(name: str, state: PersistentStateMixin) -&gt; None\n</code></pre> <p>Register a persistable object with a unique name.</p> PARAMETER DESCRIPTION <code>name</code> <p>Unique name to identify the state</p> <p> TYPE: <code>str</code> </p> <code>state</code> <p>Object implementing PersistentStateMixin</p> <p> TYPE: <code>PersistentStateMixin</code> </p> RAISES DESCRIPTION <code>KeyError</code> <p>If <code>name</code> is already registered</p> Source code in <code>src/pamiq_core/state_persistence.py</code> <pre><code>def register(self, name: str, state: PersistentStateMixin) -&gt; None:\n    \"\"\"Register a persistable object with a unique name.\n\n    Args:\n        name: Unique name to identify the state\n        state: Object implementing PersistentStateMixin\n\n    Raises:\n        KeyError: If `name` is already registered\n    \"\"\"\n    if name in self._registered_states:\n        raise KeyError(f\"State with name '{name}' is already registered\")\n    self._registered_states[name] = state\n</code></pre>"},{"location":"api/state_persistence/#pamiq_core.state_persistence.StateStore.save_state","title":"save_state","text":"<pre><code>save_state() -&gt; Path\n</code></pre> <p>Save the all states of registered objects.</p> RETURNS DESCRIPTION <code>Path</code> <p>Path to the directory where the states are saved</p> <p> TYPE: <code>Path</code> </p> RAISES DESCRIPTION <code>FileExistsError</code> <p>If the directory (<code>states_path</code>) already exists (This only occurs if multiple attempts to create directories are at the same time)</p> Source code in <code>src/pamiq_core/state_persistence.py</code> <pre><code>def save_state(self) -&gt; Path:\n    \"\"\"Save the all states of registered objects.\n\n    Returns:\n        Path: Path to the directory where the states are saved\n\n    Raises:\n        FileExistsError: If the directory (`states_path`) already exists (This only occurs if multiple attempts to create directories are at the same time)\n    \"\"\"\n    state_path = self.states_dir / datetime.now().strftime(self.state_name_format)\n    state_path.mkdir()\n    for name, state in self._registered_states.items():\n        state.save_state(state_path / name)\n    return state_path\n</code></pre>"},{"location":"api/state_persistence/#pamiq_core.state_persistence.StateStore.load_state","title":"load_state","text":"<pre><code>load_state(state_path: str | Path) -&gt; None\n</code></pre> <p>Restores the state from the <code>state_path</code> directory.</p> PARAMETER DESCRIPTION <code>state_path</code> <p>Path to the directory where the state is saved</p> <p> TYPE: <code>str | Path</code> </p> RAISES DESCRIPTION <code>FileNotFoundError</code> <p>If the specified path does not exist</p> Source code in <code>src/pamiq_core/state_persistence.py</code> <pre><code>def load_state(self, state_path: str | Path) -&gt; None:\n    \"\"\"Restores the state from the `state_path` directory.\n\n    Args:\n        state_path: Path to the directory where the state is saved\n\n    Raises:\n        FileNotFoundError: If the specified path does not exist\n    \"\"\"\n    state_path = Path(state_path)\n    if not state_path.exists():\n        raise FileNotFoundError(f\"State path: '{state_path}' not found!\")\n    for name, state in self._registered_states.items():\n        state.load_state(state_path / name)\n</code></pre>"},{"location":"api/state_persistence/#pamiq_core.state_persistence.LatestStatesKeeper","title":"pamiq_core.state_persistence.LatestStatesKeeper","text":"<pre><code>LatestStatesKeeper(\n    states_dir: str | Path,\n    state_name_pattern: str = \"*.state\",\n    max_keep: int = 10,\n    cleanup_interval: float = 60.0,\n)\n</code></pre> <p>Keeps a fixed number of state directories by removing older ones.</p> <p>This class monitors and manages the number of state directories in a specified path, ensuring only the most recent ones (up to max_keep) are retained, preventing disk space exhaustion.</p> <p>Initialize the state keeper.</p> PARAMETER DESCRIPTION <code>states_dir</code> <p>Directory where states are stored.</p> <p> TYPE: <code>str | Path</code> </p> <code>state_name_pattern</code> <p>Pattern to match state directories.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'*.state'</code> </p> <code>max_keep</code> <p>Maximum number of state directories to keep.</p> <p> TYPE: <code>int</code> DEFAULT: <code>10</code> </p> <code>cleanup_interval</code> <p>Interval for executing cleanup process.</p> <p> TYPE: <code>float</code> DEFAULT: <code>60.0</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If cleanup interval is negative.</p> Source code in <code>src/pamiq_core/state_persistence.py</code> <pre><code>def __init__(\n    self,\n    states_dir: str | Path,\n    state_name_pattern: str = \"*.state\",\n    max_keep: int = 10,\n    cleanup_interval: float = 60.0,\n) -&gt; None:\n    \"\"\"Initialize the state keeper.\n\n    Args:\n        states_dir: Directory where states are stored.\n        state_name_pattern: Pattern to match state directories.\n        max_keep: Maximum number of state directories to keep.\n        cleanup_interval: Interval for executing cleanup process.\n\n    Raises:\n        ValueError: If cleanup interval is negative.\n    \"\"\"\n    if cleanup_interval &lt; 0.0:\n        raise ValueError(\"cleanup_interval must be positive value.\")\n    self.states_dir = Path(states_dir)\n    self.state_name_pattern = state_name_pattern\n    self.max_keep = max_keep\n    self._cleanup_interval = cleanup_interval\n    self._thread = None\n    self._shutdown_event = threading.Event()\n\n    from pamiq_core.utils.reflection import (\n        get_class_module_path,  # Avoid circular import problem.\n    )\n\n    self._logger = logging.getLogger(get_class_module_path(self.__class__))\n\n    if not self.states_dir.exists():\n        self._logger.warning(\n            f\"States directory {self.states_dir} does not exist. Creating it.\"\n        )\n        self.states_dir.mkdir(parents=True, exist_ok=True)\n</code></pre>"},{"location":"api/state_persistence/#pamiq_core.state_persistence.LatestStatesKeeper.start","title":"start","text":"<pre><code>start(background: bool = True) -&gt; None\n</code></pre> <p>Start the background cleanup thread if not already running.</p> PARAMETER DESCRIPTION <code>background</code> <p>Whether to run in background thread.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/pamiq_core/state_persistence.py</code> <pre><code>def start(self, background: bool = True) -&gt; None:\n    \"\"\"Start the background cleanup thread if not already running.\n\n    Args:\n        background: Whether to run in background thread.\n    \"\"\"\n    if background:\n        if self._thread is not None:\n            return\n        self._shutdown_event.clear()\n        self._thread = threading.Thread(target=self._cleanup)\n        self._thread.start()\n        self._logger.info(\n            f\"Started background state cleanup thread. Max keep: {self.max_keep}\"\n        )\n    else:\n        self._cleanup()\n</code></pre>"},{"location":"api/state_persistence/#pamiq_core.state_persistence.LatestStatesKeeper.stop","title":"stop","text":"<pre><code>stop() -&gt; None\n</code></pre> <p>Stop the background cleanup thread if running.</p> Source code in <code>src/pamiq_core/state_persistence.py</code> <pre><code>def stop(self) -&gt; None:\n    \"\"\"Stop the background cleanup thread if running.\"\"\"\n    if self._thread is not None:\n        self._shutdown_event.set()\n        self._thread.join()\n        self._logger.info(\"Stopped background state cleanup thread\")\n        self._thread = None\n</code></pre>"},{"location":"api/state_persistence/#pamiq_core.state_persistence.LatestStatesKeeper.cleanup","title":"cleanup","text":"<pre><code>cleanup() -&gt; list[Path]\n</code></pre> <p>Clean up old state directories, keeping only the most recent ones.</p> RETURNS DESCRIPTION <code>list[Path]</code> <p>List of removed state directory paths.</p> Source code in <code>src/pamiq_core/state_persistence.py</code> <pre><code>def cleanup(self) -&gt; list[Path]:\n    \"\"\"Clean up old state directories, keeping only the most recent ones.\n\n    Returns:\n        List of removed state directory paths.\n    \"\"\"\n    if self.max_keep &lt; 0:\n        return []\n\n    # Get all state directories matching the pattern\n    state_dirs = list(self.states_dir.glob(self.state_name_pattern))\n\n    # Sort by modification time (newest first)\n    state_dirs.sort(key=lambda p: p.stat().st_mtime, reverse=True)\n\n    # Keep only max_keep number of directories\n    dirs_to_remove = state_dirs[self.max_keep :]\n\n    removed_dirs: list[Path] = []\n    for dir_path in dirs_to_remove:\n        shutil.rmtree(dir_path)\n        removed_dirs.append(dir_path)\n        self._logger.info(f\"Removed old state directory: {dir_path}\")\n    return removed_dirs\n</code></pre>"},{"location":"api/testing/","title":"Testing","text":""},{"location":"api/testing/#pamiq_core.testing.connect_components","title":"pamiq_core.testing.connect_components","text":"<pre><code>connect_components(\n    agent: Agent[Any, Any] | None = None,\n    trainers: Trainer | Mapping[str, Trainer] | None = None,\n    buffers: Mapping[str, DataBuffer[Any]] | None = None,\n    models: Mapping[str, TrainingModel[Any]] | None = None,\n) -&gt; ConnectedComponents\n</code></pre> <p>Connect PAMIQ Core components for testing or development.</p> <p>This function wires together the core components (agent, trainers, buffers, models) by establishing the appropriate connection relationships between them. It handles the creation of data users from buffers, extraction of inference models from training models, and proper attachment of all related components.</p> PARAMETER DESCRIPTION <code>agent</code> <p>Optional agent to connect with models and data collectors</p> <p> TYPE: <code>Agent[Any, Any] | None</code> DEFAULT: <code>None</code> </p> <code>trainers</code> <p>Optional trainer or mapping of trainers to connect with models and data</p> <p> TYPE: <code>Trainer | Mapping[str, Trainer] | None</code> DEFAULT: <code>None</code> </p> <code>buffers</code> <p>Optional mapping of data buffers to create data users from</p> <p> TYPE: <code>Mapping[str, DataBuffer[Any]] | None</code> DEFAULT: <code>None</code> </p> <code>models</code> <p>Optional mapping of training models to connect with trainers and agent</p> <p> TYPE: <code>Mapping[str, TrainingModel[Any]] | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>ConnectedComponents</code> <p>ConnectedComponents containing the connected component dictionaries</p> Source code in <code>src/pamiq_core/testing.py</code> <pre><code>def connect_components(\n    agent: Agent[Any, Any] | None = None,\n    trainers: Trainer | Mapping[str, Trainer] | None = None,\n    buffers: Mapping[str, DataBuffer[Any]] | None = None,\n    models: Mapping[str, TrainingModel[Any]] | None = None,\n) -&gt; ConnectedComponents:\n    \"\"\"Connect PAMIQ Core components for testing or development.\n\n    This function wires together the core components (agent, trainers, buffers, models)\n    by establishing the appropriate connection relationships between them. It handles\n    the creation of data users from buffers, extraction of inference models from\n    training models, and proper attachment of all related components.\n\n    Args:\n        agent: Optional agent to connect with models and data collectors\n        trainers: Optional trainer or mapping of trainers to connect with models and data\n        buffers: Optional mapping of data buffers to create data users from\n        models: Optional mapping of training models to connect with trainers and agent\n\n    Returns:\n        ConnectedComponents containing the connected component dictionaries\n    \"\"\"\n    if buffers is None:\n        buffers = {}\n    if models is None:\n        models = {}\n\n    if isinstance(trainers, Trainer):\n        trainers = {\"trainer\": trainers}\n\n    data_users = DataUsersDict.from_data_buffers(buffers)\n    data_collectors = data_users.data_collectors_dict\n\n    training_models = TrainingModelsDict(models)\n    inference_models = training_models.inference_models_dict\n\n    if agent is not None:\n        agent.attach_data_collectors(data_collectors)\n        agent.attach_inference_models(inference_models)\n\n    if trainers is not None:\n        trainers_dict = TrainersDict(trainers)\n        trainers_dict.attach_data_users(data_users)\n        trainers_dict.attach_training_models(training_models)\n\n    return ConnectedComponents(\n        data_users=data_users,\n        data_collectors=data_collectors,\n        training_models=training_models,\n        inference_models=inference_models,\n    )\n</code></pre>"},{"location":"api/testing/#pamiq_core.testing.ConnectedComponents","title":"pamiq_core.testing.ConnectedComponents","text":"<p>               Bases: <code>NamedTuple</code></p> <p>Container for connected PAMIQ components.</p> ATTRIBUTE DESCRIPTION <code>data_users</code> <p>Dictionary of data users created from buffers</p> <p> TYPE: <code>DataUsersDict</code> </p> <code>data_collectors</code> <p>Dictionary of data collectors associated with data users</p> <p> TYPE: <code>DataCollectorsDict</code> </p> <code>training_models</code> <p>Dictionary of training models</p> <p> TYPE: <code>TrainingModelsDict</code> </p> <code>inference_models</code> <p>Dictionary of inference models derived from training models</p> <p> TYPE: <code>InferenceModelsDict</code> </p>"},{"location":"api/testing/#pamiq_core.testing.create_mock_models","title":"pamiq_core.testing.create_mock_models","text":"<pre><code>create_mock_models(\n    has_inference_model: bool = True, inference_thread_only: bool = False\n) -&gt; tuple[Mock, Mock]\n</code></pre> <p>Create mock training and inference models for testing.</p> <p>Creates mocked instances of TrainingModel and InferenceModel with the specified configuration, properly connecting them when has_inference_model is True.</p> PARAMETER DESCRIPTION <code>has_inference_model</code> <p>Whether the training model should have an inference model</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>inference_thread_only</code> <p>Whether the model is for inference thread only</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>tuple[Mock, Mock]</code> <p>A tuple containing (training_model, inference_model) mocks</p> Source code in <code>src/pamiq_core/testing.py</code> <pre><code>def create_mock_models(\n    has_inference_model: bool = True, inference_thread_only: bool = False\n) -&gt; tuple[Mock, Mock]:\n    \"\"\"Create mock training and inference models for testing.\n\n    Creates mocked instances of TrainingModel and InferenceModel with the specified\n    configuration, properly connecting them when has_inference_model is True.\n\n    Args:\n        has_inference_model: Whether the training model should have an inference model\n        inference_thread_only: Whether the model is for inference thread only\n\n    Returns:\n        A tuple containing (training_model, inference_model) mocks\n    \"\"\"\n    training_model = Mock(TrainingModel)\n    inference_model = Mock(InferenceModel)\n    training_model.has_inference_model = has_inference_model\n    training_model.inference_thread_only = inference_thread_only\n    if has_inference_model:\n        training_model.inference_model = inference_model\n    return training_model, inference_model\n</code></pre>"},{"location":"api/testing/#pamiq_core.testing.create_mock_buffer","title":"pamiq_core.testing.create_mock_buffer","text":"<pre><code>create_mock_buffer(max_size: int = 1) -&gt; MagicMock\n</code></pre> <p>Create a mock data buffer for testing.</p> <p>Creates a MagicMock instance that mocks a DataBuffer with the specified max_size parameter. This is useful for testing components that depend on DataBuffer without implementing a full buffer.</p> PARAMETER DESCRIPTION <code>max_size</code> <p>Maximum size of the buffer. Defaults to 1.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> RETURNS DESCRIPTION <code>MagicMock</code> <p>A MagicMock object that mocks a DataBuffer.</p> Source code in <code>src/pamiq_core/testing.py</code> <pre><code>def create_mock_buffer(max_size: int = 1) -&gt; MagicMock:\n    \"\"\"Create a mock data buffer for testing.\n\n    Creates a MagicMock instance that mocks a DataBuffer with the specified\n    max_size parameter. This is useful for testing components that depend on\n    DataBuffer without implementing a full buffer.\n\n    Args:\n        max_size: Maximum size of the buffer. Defaults to 1.\n\n    Returns:\n        A MagicMock object that mocks a DataBuffer.\n    \"\"\"\n    buf = MagicMock(DataBuffer)\n    buf.max_size = max_size\n    return buf\n</code></pre>"},{"location":"api/time/","title":"Time","text":""},{"location":"api/time/#pamiq_core.time","title":"pamiq_core.time","text":"<p>PAMIQ-Core Time Module.</p> <p>This module provides a custom implementation of time-related functions with time acceleration and pause/resume features. It wraps the standard Python time module and allows for consistent time control across the system.</p> Key features <ul> <li>Time acceleration: Adjust the speed of time passage in the system.</li> <li>Pause/Resume: Ability to pause and resume the flow of time in the system.</li> <li>Thread-safe: All operations are protected by locks for use in multi-threaded environments.</li> <li>Compatible API: Provides familiar time functions like sleep, time, perf_counter, and monotonic.</li> <li>Original time functions: Provides access to the original time functions with 'fixed_' prefix.</li> </ul> Usage <pre><code>from pamiq_core import time\n\n# Get current time (affected by time scale and pause)\ncurrent_time = time.time()\n\n# Get current time (not affected by time scale or pause)\nfixed_current_time = time.fixed_time()\n\n# Sleep for 1 second (affected by time scale and pause)\ntime.sleep(1)\n\n# Sleep for 1 second (not affected by time scale or pause)\ntime.fixed_sleep(1)\n\n# Set time scale (e.g., 2x speed)\ntime.set_time_scale(2.0)\n\n# Get current time scale\ncurrent_scale = time.get_time_scale()\n\n# Pause time\ntime.pause()\n\n# Resume time\ntime.resume()\n</code></pre> <p>Note: This module is designed for use within the system and may not be suitable for general-purpose time management.</p>"},{"location":"api/time/#pamiq_core.time.TimeController","title":"TimeController","text":"<pre><code>TimeController()\n</code></pre> <p>               Bases: <code>PersistentStateMixin</code></p> Source code in <code>src/pamiq_core/time.py</code> <pre><code>def __init__(self) -&gt; None:\n    self._lock = RLock()\n    self._anchor_time = _original_time.time()\n    self._anchor_perf_counter = _original_time.perf_counter()\n    self._anchor_monotonic = _original_time.monotonic()\n    self._scaled_anchor_time = _original_time.time()\n    self._scaled_anchor_perf_counter = _original_time.perf_counter()\n    self._scaled_anchor_monotonic = _original_time.monotonic()\n\n    self._time_scale = 1.0\n    self._is_paused = False\n</code></pre>"},{"location":"api/time/#pamiq_core.time.TimeController.TimeControllerState","title":"TimeControllerState","text":"<p>               Bases: <code>TypedDict</code></p> <p>Time controller state for restarting the system.</p>"},{"location":"api/time/#pamiq_core.time.TimeController.is_paused","title":"is_paused","text":"<pre><code>is_paused() -&gt; bool\n</code></pre> <p>Public interface for checking pause.</p> Source code in <code>src/pamiq_core/time.py</code> <pre><code>@with_lock\ndef is_paused(self) -&gt; bool:\n    \"\"\"Public interface for checking pause.\"\"\"\n    return self._is_paused\n</code></pre>"},{"location":"api/time/#pamiq_core.time.TimeController.time","title":"time","text":"<pre><code>time() -&gt; float\n</code></pre> <p>Return the current time in seconds since the epoch.</p> <p>This function is affected by the current time scale and pause state.</p> RETURNS DESCRIPTION <code>float</code> <p>The current time in seconds since the epoch.</p> <p> TYPE: <code>float</code> </p> Source code in <code>src/pamiq_core/time.py</code> <pre><code>@with_lock\ndef time(self) -&gt; float:\n    \"\"\"Return the current time in seconds since the epoch.\n\n    This function is affected by the current time scale and pause state.\n\n    Returns:\n        float: The current time in seconds since the epoch.\n    \"\"\"\n    if self._is_paused:\n        return self._scaled_anchor_time\n\n    delta = _original_time.time() - self._anchor_time\n    return self._scaled_anchor_time + delta * self._time_scale\n</code></pre>"},{"location":"api/time/#pamiq_core.time.TimeController.perf_counter","title":"perf_counter","text":"<pre><code>perf_counter() -&gt; float\n</code></pre> <p>Return the value (in fractional seconds) of a performance counter.</p> <p>This function is affected by the current time scale and pause state.</p> RETURNS DESCRIPTION <code>float</code> <p>The current value of the performance counter.</p> <p> TYPE: <code>float</code> </p> Source code in <code>src/pamiq_core/time.py</code> <pre><code>@with_lock\ndef perf_counter(self) -&gt; float:\n    \"\"\"Return the value (in fractional seconds) of a performance counter.\n\n    This function is affected by the current time scale and pause state.\n\n    Returns:\n        float: The current value of the performance counter.\n    \"\"\"\n    if self._is_paused:\n        return self._scaled_anchor_perf_counter\n\n    delta = _original_time.perf_counter() - self._anchor_perf_counter\n    return self._scaled_anchor_perf_counter + delta * self._time_scale\n</code></pre>"},{"location":"api/time/#pamiq_core.time.TimeController.monotonic","title":"monotonic","text":"<pre><code>monotonic() -&gt; float\n</code></pre> <p>Return the value (in fractional seconds) of a monotonic time counter.</p> <p>This function is affected by the current time scale and pause state.</p> RETURNS DESCRIPTION <code>float</code> <p>The current value of the monotonic time counter.</p> <p> TYPE: <code>float</code> </p> Source code in <code>src/pamiq_core/time.py</code> <pre><code>@with_lock\ndef monotonic(self) -&gt; float:\n    \"\"\"Return the value (in fractional seconds) of a monotonic time\n    counter.\n\n    This function is affected by the current time scale and pause state.\n\n    Returns:\n        float: The current value of the monotonic time counter.\n    \"\"\"\n    if self._is_paused:\n        return self._scaled_anchor_monotonic\n\n    delta = _original_time.monotonic() - self._anchor_monotonic\n    return self._scaled_anchor_monotonic + delta * self._time_scale\n</code></pre>"},{"location":"api/time/#pamiq_core.time.TimeController.set_time_scale","title":"set_time_scale","text":"<pre><code>set_time_scale(time_scale: float) -&gt; None\n</code></pre> <p>Set the time scale for the system.</p> PARAMETER DESCRIPTION <code>time_scale</code> <p>The new time scale. Must be greater than 0.</p> <p> TYPE: <code>float</code> </p> RAISES DESCRIPTION <code>AssertionError</code> <p>If time_scale is not greater than 0.</p> Source code in <code>src/pamiq_core/time.py</code> <pre><code>@with_lock\ndef set_time_scale(self, time_scale: float) -&gt; None:\n    \"\"\"Set the time scale for the system.\n\n    Args:\n        time_scale (float): The new time scale. Must be greater than 0.\n\n    Raises:\n        AssertionError: If time_scale is not greater than 0.\n    \"\"\"\n    assert time_scale &gt; 0, \"Time scale must be &gt; 0\"\n    self._update_scaled_anchor_values()\n    self._update_anchor_values()\n    self._time_scale = time_scale\n</code></pre>"},{"location":"api/time/#pamiq_core.time.TimeController.get_time_scale","title":"get_time_scale","text":"<pre><code>get_time_scale() -&gt; float\n</code></pre> <p>Get the current time scale of the system.</p> RETURNS DESCRIPTION <code>float</code> <p>The current time scale.</p> <p> TYPE: <code>float</code> </p> Source code in <code>src/pamiq_core/time.py</code> <pre><code>@with_lock\ndef get_time_scale(self) -&gt; float:\n    \"\"\"Get the current time scale of the system.\n\n    Returns:\n        float: The current time scale.\n    \"\"\"\n    return self._time_scale\n</code></pre>"},{"location":"api/time/#pamiq_core.time.TimeController.sleep","title":"sleep","text":"<pre><code>sleep(secs: float) -&gt; None\n</code></pre> <p>Suspend execution for the given number of seconds.</p> <p>This function is affected by the current time scale and pause state.</p> PARAMETER DESCRIPTION <code>secs</code> <p>The number of seconds to sleep.</p> <p> TYPE: <code>float</code> </p> Source code in <code>src/pamiq_core/time.py</code> <pre><code>def sleep(self, secs: float) -&gt; None:\n    \"\"\"Suspend execution for the given number of seconds.\n\n    This function is affected by the current time scale and pause state.\n\n    Args:\n        secs (float): The number of seconds to sleep.\n    \"\"\"\n\n    with self._lock:\n        if self._is_paused:\n            return\n        time_scale = self._time_scale\n    _original_time.sleep(secs / time_scale)\n</code></pre>"},{"location":"api/time/#pamiq_core.time.TimeController.pause","title":"pause","text":"<pre><code>pause() -&gt; None\n</code></pre> <p>Pause the flow of time in the system.</p> Source code in <code>src/pamiq_core/time.py</code> <pre><code>@with_lock\ndef pause(self) -&gt; None:\n    \"\"\"Pause the flow of time in the system.\"\"\"\n    if not self._is_paused:\n        self._update_scaled_anchor_values()\n        self._is_paused = True\n</code></pre>"},{"location":"api/time/#pamiq_core.time.TimeController.resume","title":"resume","text":"<pre><code>resume() -&gt; None\n</code></pre> <p>Resume the flow of time in the system.</p> Source code in <code>src/pamiq_core/time.py</code> <pre><code>@with_lock\ndef resume(self) -&gt; None:\n    \"\"\"Resume the flow of time in the system.\"\"\"\n    if self._is_paused:\n        self._is_paused = False\n        self._update_anchor_values()\n</code></pre>"},{"location":"api/time/#pamiq_core.time.TimeController.state_dict","title":"state_dict","text":"<pre><code>state_dict() -&gt; TimeControllerState\n</code></pre> <p>Return the time controller state.</p> RETURNS DESCRIPTION <code>TimeControllerState</code> <p>State information that can reproduce the current time flow progression of the system.</p> <p> TYPE: <code>TimeControllerState</code> </p> Source code in <code>src/pamiq_core/time.py</code> <pre><code>@with_lock\ndef state_dict(self) -&gt; TimeControllerState:\n    \"\"\"Return the time controller state.\n\n    Returns:\n        TimeControllerState: State information that can reproduce the current time flow progression of the system.\n    \"\"\"\n    self._update_scaled_anchor_values()\n    return self.TimeControllerState(\n        scaled_anchor_time=self._scaled_anchor_time,\n        scaled_anchor_monotonic=self._scaled_anchor_monotonic,\n        scaled_anchor_perf_counter=self._scaled_anchor_perf_counter,\n    )\n</code></pre>"},{"location":"api/time/#pamiq_core.time.TimeController.load_state_dict","title":"load_state_dict","text":"<pre><code>load_state_dict(state_dict: TimeControllerState) -&gt; None\n</code></pre> <p>Loads states.</p> <p>When a state is loaded, the system time starts from the time the state was retrieved.</p> PARAMETER DESCRIPTION <code>state_dict</code> <p>The dict which contains state values.</p> <p> TYPE: <code>TimeControllerState</code> </p> Source code in <code>src/pamiq_core/time.py</code> <pre><code>@with_lock\ndef load_state_dict(self, state_dict: TimeControllerState) -&gt; None:\n    \"\"\"Loads states.\n\n    When a state is loaded, the system time starts from the time the state was retrieved.\n\n    Args:\n        state_dict (TimeControllerState): The dict which contains state values.\n    \"\"\"\n    self._scaled_anchor_time = state_dict[\"scaled_anchor_time\"]\n    self._scaled_anchor_monotonic = state_dict[\"scaled_anchor_monotonic\"]\n    self._scaled_anchor_perf_counter = state_dict[\"scaled_anchor_perf_counter\"]\n    self._update_anchor_values()\n</code></pre>"},{"location":"api/time/#pamiq_core.time.TimeController.save_state","title":"save_state","text":"<pre><code>save_state(path: Path) -&gt; None\n</code></pre> <p>Save the current TimeController state to disk.</p> PARAMETER DESCRIPTION <code>path</code> <p>Base path where the state will be saved. Will be appended with  .pkl extension.</p> <p> TYPE: <code>Path</code> </p> Source code in <code>src/pamiq_core/time.py</code> <pre><code>@override\ndef save_state(self, path: Path) -&gt; None:\n    \"\"\"Save the current TimeController state to disk.\n\n    Args:\n        path: Base path where the state will be saved. Will be appended with\n             .pkl extension.\n    \"\"\"\n    save_pickle(self.state_dict(), path.with_suffix(\".pkl\"))\n</code></pre>"},{"location":"api/time/#pamiq_core.time.TimeController.load_state","title":"load_state","text":"<pre><code>load_state(path: Path) -&gt; None\n</code></pre> <p>Load TimeController state from disk.</p> PARAMETER DESCRIPTION <code>path</code> <p>Base path where the state was previously saved. Will be appended  with .pkl extension.</p> <p> TYPE: <code>Path</code> </p> Source code in <code>src/pamiq_core/time.py</code> <pre><code>@override\ndef load_state(self, path: Path) -&gt; None:\n    \"\"\"Load TimeController state from disk.\n\n    Args:\n        path: Base path where the state was previously saved. Will be appended\n             with .pkl extension.\n    \"\"\"\n    self.load_state_dict(load_pickle(path.with_suffix(\".pkl\")))\n</code></pre>"},{"location":"api/time/#pamiq_core.time.get_global_time_controller","title":"get_global_time_controller","text":"<pre><code>get_global_time_controller() -&gt; TimeController\n</code></pre> <p>Retrieves the global instance of TimeController.</p> RETURNS DESCRIPTION <code>TimeController</code> <p>Global instance of TimeController</p> Source code in <code>src/pamiq_core/time.py</code> <pre><code>def get_global_time_controller() -&gt; TimeController:\n    \"\"\"Retrieves the global instance of TimeController.\n\n    Returns:\n        Global instance of TimeController\n    \"\"\"\n    return _time_controller\n</code></pre>"},{"location":"api/torch/","title":"Torch\ud83d\udd25","text":""},{"location":"api/torch/#pamiq_core.torch.TorchTrainingModel","title":"pamiq_core.torch.TorchTrainingModel","text":"<pre><code>TorchTrainingModel(\n    model: T,\n    has_inference_model: bool = True,\n    inference_thread_only: bool = False,\n    device: device | str | None = None,\n    dtype: dtype | None = None,\n    inference_procedure: InferenceProcedureCallable[T] | str = default_infer_procedure,\n    pretrained_parameter_file: str | Path | None = None,\n    compile: bool = False,\n)\n</code></pre> <p>               Bases: <code>TrainingModel[TorchInferenceModel[T]]</code></p> <p>PyTorch model wrapper for parallel training and inference.</p> <p>This class enables efficient multi-threaded operation where training and inference can run in parallel on separate model instances. It manages model synchronization between threads and provides various initialization options.</p> Type Parameters <p>T: The type of the PyTorch model (must be nn.Module subclass).</p> <p>Initialize the TorchTrainingModel.</p> PARAMETER DESCRIPTION <code>model</code> <p>The PyTorch model to wrap for training.</p> <p> TYPE: <code>T</code> </p> <code>has_inference_model</code> <p>Whether to create a separate inference model. If False, inference is not supported.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>inference_thread_only</code> <p>If True, the same model instance is shared between training and inference (no copying). Use this when the model is only used for inference.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>device</code> <p>Device to place the model on. If None, keeps the model on its current device.</p> <p> TYPE: <code>device | str | None</code> DEFAULT: <code>None</code> </p> <code>dtype</code> <p>Data type for the model parameters. If specified, converts the model to this dtype.</p> <p> TYPE: <code>dtype | None</code> DEFAULT: <code>None</code> </p> <code>inference_procedure</code> <p>The procedure to use for inference. Can be: - A callable following the InferenceProcedureCallable protocol - A string naming a method on the model class - The default_infer_procedure function (default)</p> <p> TYPE: <code>InferenceProcedureCallable[T] | str</code> DEFAULT: <code>default_infer_procedure</code> </p> <code>pretrained_parameter_file</code> <p>Path to a pre-trained model parameter file. If provided, loads parameters from this file after initialization.</p> <p> TYPE: <code>str | Path | None</code> DEFAULT: <code>None</code> </p> <code>compile</code> <p>Whether to compile the model using torch.compile() for potentially better performance. If has_inference_model is True, both models are compiled.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RAISES DESCRIPTION <code>AttributeError</code> <p>If inference_procedure is a string but doesn't exist in model class attributes.</p> <code>ValueError</code> <p>If inference_procedure is a string but doesn't refer to a callable method on the model class.</p> Source code in <code>src/pamiq_core/torch/model.py</code> <pre><code>@override\ndef __init__(\n    self,\n    model: T,\n    has_inference_model: bool = True,\n    inference_thread_only: bool = False,\n    device: torch.device | str | None = None,\n    dtype: torch.dtype | None = None,\n    inference_procedure: InferenceProcedureCallable[T]\n    | str = default_infer_procedure,\n    pretrained_parameter_file: str | Path | None = None,\n    compile: bool = False,\n):\n    \"\"\"Initialize the TorchTrainingModel.\n\n    Args:\n        model: The PyTorch model to wrap for training.\n        has_inference_model: Whether to create a separate inference model.\n            If False, inference is not supported.\n        inference_thread_only: If True, the same model instance is shared\n            between training and inference (no copying). Use this when\n            the model is only used for inference.\n        device: Device to place the model on. If None, keeps the model\n            on its current device.\n        dtype: Data type for the model parameters. If specified, converts\n            the model to this dtype.\n        inference_procedure: The procedure to use for inference. Can be:\n            - A callable following the InferenceProcedureCallable protocol\n            - A string naming a method on the model class\n            - The default_infer_procedure function (default)\n        pretrained_parameter_file: Path to a pre-trained model parameter\n            file. If provided, loads parameters from this file after\n            initialization.\n        compile: Whether to compile the model using torch.compile() for\n            potentially better performance. If has_inference_model is True,\n            both models are compiled.\n\n    Raises:\n        AttributeError: If inference_procedure is a string but doesn't exist in model class attributes.\n        ValueError: If inference_procedure is a string but doesn't refer\n            to a callable method on the model class.\n    \"\"\"\n    super().__init__(has_inference_model, inference_thread_only)\n    if dtype is not None:\n        model = model.type(dtype)\n    self.model = model\n    if device is None:  # prevents from moving the model to cpu unintentionally.\n        device = get_device(model)\n\n    if isinstance(inference_procedure, str):\n        method_name = inference_procedure\n        if not hasattr(model.__class__, method_name):\n            raise AttributeError(\n                f\"The model class {model.__class__.__name__} does not have \"\n                f\"a method named '{method_name}'\"\n            )\n        inference_procedure = getattr(model.__class__, method_name)\n        if not callable(inference_procedure):\n            raise ValueError(\n                f\"The specified inference_procedure '{method_name}' \"\n                f\"is not a callable method on {model.__class__.__name__}\"\n            )\n\n    self._inference_procedure = inference_procedure\n    self.model.to(device)\n\n    if pretrained_parameter_file is not None:\n        self.model.load_state_dict(\n            torch.load(pretrained_parameter_file, map_location=device)  # pyright: ignore[reportUnknownMemberType]\n        )\n\n    if compile:\n        if self.has_inference_model:\n            # copy before compile\n            self.inference_model._raw_model.compile()  # pyright: ignore[reportPrivateUsage, reportUnknownMemberType]\n        self.model.compile()  # pyright: ignore[reportUnknownMemberType, ]\n</code></pre>"},{"location":"api/torch/#pamiq_core.torch.TorchTrainingModel.sync_impl","title":"sync_impl","text":"<pre><code>sync_impl(inference_model: TorchInferenceModel[T]) -&gt; None\n</code></pre> <p>Synchronize training model parameters to the inference model.</p> <p>This method implements an efficient parameter synchronization strategy by swapping model references and copying state dictionaries. It preserves gradients on the training model during the sync operation.</p> PARAMETER DESCRIPTION <code>inference_model</code> <p>The inference model to synchronize parameters to.</p> <p> TYPE: <code>TorchInferenceModel[T]</code> </p> Note <p>The models are put in eval mode during sync and returned to train mode afterwards to ensure proper behavior of layers like BatchNorm and Dropout.</p> Source code in <code>src/pamiq_core/torch/model.py</code> <pre><code>@override\ndef sync_impl(self, inference_model: TorchInferenceModel[T]) -&gt; None:\n    \"\"\"Synchronize training model parameters to the inference model.\n\n    This method implements an efficient parameter synchronization strategy\n    by swapping model references and copying state dictionaries. It preserves\n    gradients on the training model during the sync operation.\n\n    Args:\n        inference_model: The inference model to synchronize parameters to.\n\n    Note:\n        The models are put in eval mode during sync and returned to train\n        mode afterwards to ensure proper behavior of layers like BatchNorm\n        and Dropout.\n    \"\"\"\n\n    self.model.eval()\n\n    # Hold the grads.\n    grads: list[torch.Tensor | None] = []\n    for p in self.model.parameters():\n        grads.append(p.grad)\n        p.grad = None\n\n    # Swap the training model and the inference model.\n    self.model, inference_model._raw_model = (  # pyright: ignore[reportPrivateUsage]\n        inference_model._raw_model,  # pyright: ignore[reportPrivateUsage]\n        self.model,\n    )\n    self.model.load_state_dict(\n        self.inference_model._raw_model.state_dict()  # pyright: ignore[reportPrivateUsage]\n    )\n\n    # Assign the model grads.\n    for i, p in enumerate(self.model.parameters()):\n        p.grad = grads[i]\n\n    self.model.train()\n</code></pre>"},{"location":"api/torch/#pamiq_core.torch.TorchTrainingModel.forward","title":"forward","text":"<pre><code>forward(*args: Any, **kwds: Any) -&gt; Any\n</code></pre> <p>Forward pass through the training model.</p> PARAMETER DESCRIPTION <code>*args</code> <p>Positional arguments to pass to the model.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>()</code> </p> <code>**kwds</code> <p>Keyword arguments to pass to the model.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>Any</code> <p>The output from the model's forward pass.</p> Source code in <code>src/pamiq_core/torch/model.py</code> <pre><code>@override\ndef forward(self, *args: Any, **kwds: Any) -&gt; Any:\n    \"\"\"Forward pass through the training model.\n\n    Args:\n        *args: Positional arguments to pass to the model.\n        **kwds: Keyword arguments to pass to the model.\n\n    Returns:\n        The output from the model's forward pass.\n    \"\"\"\n    return self.model(*args, **kwds)\n</code></pre>"},{"location":"api/torch/#pamiq_core.torch.TorchTrainingModel.save_state","title":"save_state","text":"<pre><code>save_state(path: Path) -&gt; None\n</code></pre> <p>Save the model parameters.</p> PARAMETER DESCRIPTION <code>path</code> <p>Base path for saving the model state. The actual file will be saved as \"{path}.pt\".</p> <p> TYPE: <code>Path</code> </p> Source code in <code>src/pamiq_core/torch/model.py</code> <pre><code>@override\ndef save_state(self, path: Path) -&gt; None:\n    \"\"\"Save the model parameters.\n\n    Args:\n        path: Base path for saving the model state. The actual file\n            will be saved as \"{path}.pt\".\n    \"\"\"\n    torch.save(self.model.state_dict(), f\"{path}.pt\")  # pyright: ignore[reportUnknownMemberType]\n</code></pre>"},{"location":"api/torch/#pamiq_core.torch.TorchTrainingModel.load_state","title":"load_state","text":"<pre><code>load_state(path: Path) -&gt; None\n</code></pre> <p>Load model parameters.</p> PARAMETER DESCRIPTION <code>path</code> <p>Base path for loading the model state. The actual file loaded will be \"{path}.pt\".</p> <p> TYPE: <code>Path</code> </p> Source code in <code>src/pamiq_core/torch/model.py</code> <pre><code>@override\ndef load_state(self, path: Path) -&gt; None:\n    \"\"\"Load model parameters.\n\n    Args:\n        path: Base path for loading the model state. The actual file\n            loaded will be \"{path}.pt\".\n    \"\"\"\n    self.model.load_state_dict(torch.load(f\"{path}.pt\"))  # pyright: ignore[reportUnknownMemberType]\n</code></pre>"},{"location":"api/torch/#pamiq_core.torch.TorchInferenceModel","title":"pamiq_core.torch.TorchInferenceModel","text":"<pre><code>TorchInferenceModel(model: T, inference_procedure: InferenceProcedureCallable[T])\n</code></pre> <p>               Bases: <code>InferenceModel</code></p> <p>Thread-safe wrapper for PyTorch models used in inference.</p> <p>This class provides a thread-safe interface for performing inference with PyTorch models in multi-threaded environments. It uses a lock to ensure that model updates and inference operations don't interfere with each other.</p> Type Parameters <p>T: The type of the PyTorch model (must be nn.Module subclass).</p> <p>Initialize the TorchInferenceModel.</p> PARAMETER DESCRIPTION <code>model</code> <p>A PyTorch model to wrap for thread-safe inference.</p> <p> TYPE: <code>T</code> </p> <code>inference_procedure</code> <p>A callable that defines how to perform inference with the model. It should specify the model as the first argument, followed by additional arguments.</p> <p> TYPE: <code>InferenceProcedureCallable[T]</code> </p> Source code in <code>src/pamiq_core/torch/model.py</code> <pre><code>def __init__(\n    self, model: T, inference_procedure: InferenceProcedureCallable[T]\n) -&gt; None:\n    \"\"\"Initialize the TorchInferenceModel.\n\n    Args:\n        model: A PyTorch model to wrap for thread-safe inference.\n        inference_procedure: A callable that defines how to perform\n            inference with the model. It should specify the model as the\n            first argument, followed by additional arguments.\n    \"\"\"\n    self._model = model\n    self._inference_procedure = inference_procedure\n    self._lock = RLock()\n</code></pre>"},{"location":"api/torch/#pamiq_core.torch.TorchInferenceModel.infer","title":"infer","text":"<pre><code>infer(*args: Any, **kwds: Any) -&gt; Any\n</code></pre> <p>Perform thread-safe inference with gradient computation disabled.</p> <p>This method executes the inference procedure with the model while ensuring thread safety through locking and disabling gradient computation for efficiency.</p> PARAMETER DESCRIPTION <code>*args</code> <p>Positional arguments to pass to the inference procedure.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>()</code> </p> <code>**kwds</code> <p>Keyword arguments to pass to the inference procedure.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>Any</code> <p>The output from the inference procedure.</p> Source code in <code>src/pamiq_core/torch/model.py</code> <pre><code>@torch.inference_mode()\n@override\ndef infer(self, *args: Any, **kwds: Any) -&gt; Any:\n    \"\"\"Perform thread-safe inference with gradient computation disabled.\n\n    This method executes the inference procedure with the model while\n    ensuring thread safety through locking and disabling gradient\n    computation for efficiency.\n\n    Args:\n        *args: Positional arguments to pass to the inference procedure.\n        **kwds: Keyword arguments to pass to the inference procedure.\n\n    Returns:\n        The output from the inference procedure.\n    \"\"\"\n    with self._lock:\n        return self._inference_procedure(self._model, *args, **kwds)\n</code></pre>"},{"location":"api/torch/#pamiq_core.torch.TorchTrainer","title":"pamiq_core.torch.TorchTrainer","text":"<pre><code>TorchTrainer(\n    training_condition_data_user: str | None = None,\n    min_buffer_size: int = 0,\n    min_new_data_count: int = 0,\n)\n</code></pre> <p>               Bases: <code>Trainer</code></p> <p>Base class for PyTorch model training in pamiq-core.</p> <p>This trainer integrates PyTorch models with the pamiq-core framework, providing functionality for optimizer configuration, state persistence, and model type validation. It automatically handles the setup and teardown of optimizers and learning rate schedulers during the training process.</p> <p>Subclasses should implement the <code>configure_optimizers</code> and <code>train</code> methods to define the specific training behavior.</p> <p>Initialize the PyTorch trainer.</p> <p>Sets up empty containers for optimizers, schedulers, and their respective states. Actual optimizer and scheduler instances will be created during the setup phase.</p> PARAMETER DESCRIPTION <code>training_condition_data_user</code> <p>Name of the data user to check for trainability. If None, trainer is always trainable.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>min_buffer_size</code> <p>Minimum total data points required in the buffer.</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> <code>min_new_data_count</code> <p>Minimum number of new data points required since last training.</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> Source code in <code>src/pamiq_core/torch/trainer.py</code> <pre><code>def __init__(\n    self,\n    training_condition_data_user: str | None = None,\n    min_buffer_size: int = 0,\n    min_new_data_count: int = 0,\n) -&gt; None:\n    \"\"\"Initialize the PyTorch trainer.\n\n    Sets up empty containers for optimizers, schedulers, and their\n    respective states. Actual optimizer and scheduler instances will\n    be created during the setup phase.\n\n    Args:\n        training_condition_data_user: Name of the data user to check for trainability.\n            If None, trainer is always trainable.\n        min_buffer_size: Minimum total data points required in the buffer.\n        min_new_data_count: Minimum number of new data points required since last training.\n    \"\"\"\n    super().__init__(\n        training_condition_data_user,\n        min_buffer_size,\n        min_new_data_count,\n    )\n\n    # Containers for optimizer and scheduler instances\n    self.optimizers: OptimizersDict = {}\n    self.lr_schedulers: LRSchedulersDict = {}\n\n    # Containers for persistent optimizer and scheduler states\n    self.optimizer_states: dict[str, StateDict] = {}\n    self.lr_scheduler_states: dict[str, StateDict] = {}\n</code></pre>"},{"location":"api/torch/#pamiq_core.torch.TorchTrainer.get_torch_training_model","title":"get_torch_training_model","text":"<pre><code>get_torch_training_model(\n    name: str, module_cls: type[T] = nn.Module\n) -&gt; TorchTrainingModel[T]\n</code></pre> <p>Get a TorchTrainingModel with type checking. Retrieves a PyTorch model training model by name and validates internal model type.</p> PARAMETER DESCRIPTION <code>name</code> <p>Name of the model to retrieve.</p> <p> TYPE: <code>str</code> </p> <code>module_cls</code> <p>Expected internal module class.</p> <p> TYPE: <code>type[T]</code> DEFAULT: <code>Module</code> </p> RETURNS DESCRIPTION <code>TorchTrainingModel[T]</code> <p>An instance of TorchTrainingModel with specified model type.</p> <p>Raises:     TypeError: If the model is not a TorchTrainingModel or internal model is not specified module class.</p> Source code in <code>src/pamiq_core/torch/trainer.py</code> <pre><code>def get_torch_training_model[T: nn.Module](\n    self, name: str, module_cls: type[T] = nn.Module\n) -&gt; TorchTrainingModel[T]:\n    \"\"\"Get a TorchTrainingModel with type checking. Retrieves a PyTorch\n    model training model by name and validates internal model type.\n\n    Args:\n        name: Name of the model to retrieve.\n        module_cls: Expected internal module class.\n\n    Returns:\n        An instance of TorchTrainingModel with specified model type.\n    Raises:\n        TypeError: If the model is not a TorchTrainingModel or internal model is not specified module class.\n    \"\"\"\n    training_model = self.get_training_model(name)\n    if not isinstance(training_model, TorchTrainingModel):\n        raise TypeError(f\"Model {name} is not a instance of TorchTrainingModel\")\n\n    training_model = cast(TorchTrainingModel[T], training_model)\n\n    if not isinstance(training_model.model, module_cls):\n        raise TypeError(\n            f\"Internal model is not a instance of {module_cls.__name__}\"\n        )\n    return training_model\n</code></pre>"},{"location":"api/torch/#pamiq_core.torch.TorchTrainer.create_optimizers","title":"create_optimizers  <code>abstractmethod</code>","text":"<pre><code>create_optimizers() -&gt; OptimizersSetup\n</code></pre> <p>Create and return optimizers and optional schedulers for training. Implementations should create optimizers for each model being trained, and optionally create learning rate schedulers. Returns:     Either:     - Dictionary mapping names to optimizers     - Tuple containing (optimizers dictionary, schedulers dictionary)</p> Source code in <code>src/pamiq_core/torch/trainer.py</code> <pre><code>@abstractmethod\ndef create_optimizers(self) -&gt; OptimizersSetup:\n    \"\"\"Create and return optimizers and optional schedulers for training.\n    Implementations should create optimizers for each model being trained,\n    and optionally create learning rate schedulers.\n    Returns:\n        Either:\n        - Dictionary mapping names to optimizers\n        - Tuple containing (optimizers dictionary, schedulers dictionary)\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/torch/#pamiq_core.torch.TorchTrainer.setup","title":"setup","text":"<pre><code>setup() -&gt; None\n</code></pre> <p>Set up the training environment.</p> <p>Initializes optimizers and schedulers by calling the <code>configure_optimizers</code> method and restores their states if previously saved.</p> Source code in <code>src/pamiq_core/torch/trainer.py</code> <pre><code>@override\ndef setup(self) -&gt; None:\n    \"\"\"Set up the training environment.\n\n    Initializes optimizers and schedulers by calling the `configure_optimizers`\n    method and restores their states if previously saved.\n    \"\"\"\n    super().setup()\n    self._setup_optimizers_and_schedulers()\n</code></pre>"},{"location":"api/torch/#pamiq_core.torch.TorchTrainer.teardown","title":"teardown","text":"<pre><code>teardown() -&gt; None\n</code></pre> <p>Clean up after training.</p> <p>Keeps the current state of optimizers and schedulers before cleanup.</p> Source code in <code>src/pamiq_core/torch/trainer.py</code> <pre><code>@override\ndef teardown(self) -&gt; None:\n    \"\"\"Clean up after training.\n\n    Keeps the current state of optimizers and schedulers before\n    cleanup.\n    \"\"\"\n    super().teardown()\n    self._keep_optimizer_and_scheduler_states()\n</code></pre>"},{"location":"api/torch/#pamiq_core.torch.TorchTrainer.save_state","title":"save_state","text":"<pre><code>save_state(path: Path) -&gt; None\n</code></pre> <p>Save trainer state to disk.</p> <p>Persists the states of all optimizers and schedulers to the specified directory path.</p> PARAMETER DESCRIPTION <code>path</code> <p>Directory path where state should be saved</p> <p> TYPE: <code>Path</code> </p> Source code in <code>src/pamiq_core/torch/trainer.py</code> <pre><code>@override\ndef save_state(self, path: Path) -&gt; None:\n    \"\"\"Save trainer state to disk.\n\n    Persists the states of all optimizers and schedulers to the specified\n    directory path.\n\n    Args:\n        path: Directory path where state should be saved\n    \"\"\"\n    super().save_state(path)\n\n    # Before this method performed, the state of the optimizer or LR scheduler have already been kept by the `teardown` method.\n\n    # Save optimizer states to disk\n    for name, optimizer_state in self.optimizer_states.items():\n        torch.save(optimizer_state, path / f\"{name}.optim.pt\")  # pyright: ignore[reportUnknownMemberType]\n\n    # Save scheduler states to disk\n    for name, scheduler_state in self.lr_scheduler_states.items():\n        torch.save(scheduler_state, path / f\"{name}.lrsch.pt\")  # pyright: ignore[reportUnknownMemberType]\n</code></pre>"},{"location":"api/torch/#pamiq_core.torch.TorchTrainer.load_state","title":"load_state","text":"<pre><code>load_state(path: Path) -&gt; None\n</code></pre> <p>Load trainer state from disk.</p> <p>Loads the previously saved states of optimizers and schedulers from the specified directory path.</p> PARAMETER DESCRIPTION <code>path</code> <p>Directory path from where state should be loaded</p> <p> TYPE: <code>Path</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If the path does not exist or is not a directory</p> Source code in <code>src/pamiq_core/torch/trainer.py</code> <pre><code>@override\ndef load_state(self, path: Path) -&gt; None:\n    \"\"\"Load trainer state from disk.\n\n    Loads the previously saved states of optimizers and schedulers from\n    the specified directory path.\n\n    Args:\n        path: Directory path from where state should be loaded\n\n    Raises:\n        ValueError: If the path does not exist or is not a directory\n    \"\"\"\n    if not path.is_dir():\n        raise ValueError(f\"Path {path} is not a directory or does not exist\")\n\n    super().load_state(path)\n\n    # Load optimizer states from disk\n    for optimizer_path in path.glob(\"*.optim.pt\"):\n        name = optimizer_path.name.replace(\".optim.pt\", \"\")\n        self.optimizer_states[name] = torch.load(optimizer_path)  # pyright: ignore[reportUnknownMemberType]\n\n    # Load scheduler states from disk\n    for scheduler_path in path.glob(\"*.lrsch.pt\"):\n        name = scheduler_path.name.replace(\".lrsch.pt\", \"\")\n        self.lr_scheduler_states[name] = torch.load(scheduler_path)  # pyright: ignore[reportUnknownMemberType]\n</code></pre>"},{"location":"api/torch/#pamiq_core.torch.get_device","title":"pamiq_core.torch.get_device","text":"<pre><code>get_device(module: Module, default_device: device | None = None) -&gt; torch.device\n</code></pre> <p>Retrieves the device where the module runs.</p> PARAMETER DESCRIPTION <code>module</code> <p>A module that you want to know which device it runs on.</p> <p> TYPE: <code>Module</code> </p> <code>default_device</code> <p>A device to return if any device not found.</p> <p> TYPE: <code>device | None</code> DEFAULT: <code>None</code> </p> <p>Returns:     A device that the module uses or default_device.</p> Source code in <code>src/pamiq_core/torch/model.py</code> <pre><code>def get_device(\n    module: nn.Module, default_device: torch.device | None = None\n) -&gt; torch.device:\n    \"\"\"Retrieves the device where the module runs.\n\n    Args:\n        module: A module that you want to know which device it runs on.\n        default_device: A device to return if any device not found.\n    Returns:\n        A device that the module uses or default_device.\n    \"\"\"\n    for param in module.parameters():\n        return param.device\n    for buf in module.buffers():\n        return buf.device\n    if default_device is None:\n        default_device = torch.get_default_device()\n    return default_device\n</code></pre>"},{"location":"api/torch/#pamiq_core.torch.default_infer_procedure","title":"pamiq_core.torch.default_infer_procedure","text":"<pre><code>default_infer_procedure(model: Module, *args: Any, **kwds: Any) -&gt; Any\n</code></pre> <p>Default inference procedure with device placement.</p> <p>This function automatically moves tensor arguments to the same device as the model before performing inference. Non-tensor arguments are passed through unchanged.</p> PARAMETER DESCRIPTION <code>model</code> <p>The model to infer.</p> <p> TYPE: <code>Module</code> </p> <code>*args</code> <p>Positional arguments to pass to the model. Tensors will be moved to the model's device.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>()</code> </p> <code>**kwds</code> <p>Keyword arguments to pass to the model. Tensor values will be moved to the model's device.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>Any</code> <p>The output from the model's forward pass.</p> Note <p>When overriding this method, ensure that input tensors are properly sent to the correct device to avoid device mismatch.</p> Source code in <code>src/pamiq_core/torch/model.py</code> <pre><code>def default_infer_procedure(model: nn.Module, *args: Any, **kwds: Any) -&gt; Any:\n    \"\"\"Default inference procedure with device placement.\n\n    This function automatically moves tensor arguments to the same device\n    as the model before performing inference. Non-tensor arguments are\n    passed through unchanged.\n\n    Args:\n        model: The model to infer.\n        *args: Positional arguments to pass to the model. Tensors will be\n            moved to the model's device.\n        **kwds: Keyword arguments to pass to the model. Tensor values will\n            be moved to the model's device.\n\n    Returns:\n        The output from the model's forward pass.\n\n    Note:\n        When overriding this method, ensure that input tensors are properly\n        sent to the correct device to avoid device mismatch.\n    \"\"\"\n    device = get_device(model)\n    new_args: list[Any] = []\n    new_kwds: dict[str, Any] = {}\n    for i in args:\n        if isinstance(i, torch.Tensor):\n            i = i.to(device)\n        new_args.append(i)\n\n    for k, v in kwds.items():\n        if isinstance(v, torch.Tensor):\n            v = v.to(device)\n        new_kwds[k] = v\n\n    return model(*new_args, **new_kwds)\n</code></pre>"},{"location":"api/trainer/","title":"Trainer","text":""},{"location":"api/trainer/#pamiq_core.trainer.Trainer","title":"pamiq_core.trainer.Trainer","text":"<pre><code>Trainer(\n    training_condition_data_user: str | None = None,\n    min_buffer_size: int = 0,\n    min_new_data_count: int = 0,\n)\n</code></pre> <p>               Bases: <code>ABC</code>, <code>PersistentStateMixin</code>, <code>ThreadEventMixin</code></p> <p>Abstract base trainer class.</p> <p>The <code>run</code> method is called repeatedly in the training thread.</p> Override the following methods <ul> <li><code>on_training_models_attached</code>: Callback method for when training models are attached to the trainer.</li> <li><code>on_data_users_attached</code>: Callback method when data_users are attached to the trainer.</li> <li><code>is_trainable</code>: Return whether the training can be executed.</li> <li><code>setup</code>: To setup before training starts.</li> <li><code>train</code>: The training process.</li> <li><code>teardown</code>: To teardown after training.</li> </ul> <p>Models and data buffers become available after the thread has started.</p> <p>Initialize a trainer.</p> PARAMETER DESCRIPTION <code>training_condition_data_user</code> <p>Name of the data user to check for trainability. If None, trainer is always trainable.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>min_buffer_size</code> <p>Minimum total data points required in the buffer.</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> <code>min_new_data_count</code> <p>Minimum number of new data points required since last training.</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> Source code in <code>src/pamiq_core/trainer/base.py</code> <pre><code>def __init__(\n    self,\n    training_condition_data_user: str | None = None,\n    min_buffer_size: int = 0,\n    min_new_data_count: int = 0,\n) -&gt; None:\n    \"\"\"Initialize a trainer.\n\n    Args:\n        training_condition_data_user: Name of the data user to check for trainability.\n            If None, trainer is always trainable.\n        min_buffer_size: Minimum total data points required in the buffer.\n        min_new_data_count: Minimum number of new data points required since last training.\n    \"\"\"\n    super().__init__()\n    self._retrieved_model_names: set[str] = set()\n    self._training_condition_data_user = training_condition_data_user\n    self._min_buffer_size = min_buffer_size\n    self._min_new_data_count = min_new_data_count\n    self._previous_training_time = float(\"-inf\")\n</code></pre>"},{"location":"api/trainer/#pamiq_core.trainer.Trainer.attach_training_models","title":"attach_training_models","text":"<pre><code>attach_training_models(training_models: TrainingModelsDict) -&gt; None\n</code></pre> <p>Attaches TrainingModelsDict to this trainer.</p> Source code in <code>src/pamiq_core/trainer/base.py</code> <pre><code>def attach_training_models(self, training_models: TrainingModelsDict) -&gt; None:\n    \"\"\"Attaches TrainingModelsDict to this trainer.\"\"\"\n    self._training_models = training_models\n    self.on_training_models_attached()\n</code></pre>"},{"location":"api/trainer/#pamiq_core.trainer.Trainer.on_training_models_attached","title":"on_training_models_attached","text":"<pre><code>on_training_models_attached() -&gt; None\n</code></pre> <p>Callback method for when training models are attached to the trainer.</p> <p>Use :meth:<code>get_training_model</code> to retrieve the model that will be trained.</p> Source code in <code>src/pamiq_core/trainer/base.py</code> <pre><code>def on_training_models_attached(self) -&gt; None:\n    \"\"\"Callback method for when training models are attached to the\n    trainer.\n\n    Use :meth:`get_training_model` to retrieve the model that will be trained.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/trainer/#pamiq_core.trainer.Trainer.attach_data_users","title":"attach_data_users","text":"<pre><code>attach_data_users(data_users: DataUsersDict) -&gt; None\n</code></pre> <p>Attaches DataUsersDict to this trainer.</p> Source code in <code>src/pamiq_core/trainer/base.py</code> <pre><code>def attach_data_users(self, data_users: DataUsersDict) -&gt; None:\n    \"\"\"Attaches DataUsersDict to this trainer.\"\"\"\n    self._data_users = data_users\n    self.on_data_users_attached()\n</code></pre>"},{"location":"api/trainer/#pamiq_core.trainer.Trainer.on_data_users_attached","title":"on_data_users_attached","text":"<pre><code>on_data_users_attached() -&gt; None\n</code></pre> <p>Callback method when data users are attached to the trainer.</p> <p>Use :meth:<code>get_data_user</code> to obtain the data user class for dataset.</p> Source code in <code>src/pamiq_core/trainer/base.py</code> <pre><code>def on_data_users_attached(self) -&gt; None:\n    \"\"\"Callback method when data users are attached to the trainer.\n\n    Use :meth:`get_data_user` to obtain the data user class for dataset.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/trainer/#pamiq_core.trainer.Trainer.get_training_model","title":"get_training_model","text":"<pre><code>get_training_model(name: str) -&gt; TrainingModel[Any]\n</code></pre> <p>Retrieves the training model.</p> <p>If the specified model includes an inference model, it is automatically synchronized after training.</p> Source code in <code>src/pamiq_core/trainer/base.py</code> <pre><code>def get_training_model(self, name: str) -&gt; TrainingModel[Any]:\n    \"\"\"Retrieves the training model.\n\n    If the specified model includes an inference model, it is\n    automatically synchronized after training.\n    \"\"\"\n    model = self._training_models[name]\n    self._retrieved_model_names.add(name)\n    return model\n</code></pre>"},{"location":"api/trainer/#pamiq_core.trainer.Trainer.get_data_user","title":"get_data_user","text":"<pre><code>get_data_user(name: str) -&gt; DataUser[Any]\n</code></pre> <p>Retrieves the data user.</p> Source code in <code>src/pamiq_core/trainer/base.py</code> <pre><code>def get_data_user(self, name: str) -&gt; DataUser[Any]:\n    \"\"\"Retrieves the data user.\"\"\"\n    return self._data_users[name]\n</code></pre>"},{"location":"api/trainer/#pamiq_core.trainer.Trainer.is_trainable","title":"is_trainable","text":"<pre><code>is_trainable() -&gt; bool\n</code></pre> <p>Determines if the training can be executed.</p> <p>Checks if training can proceed based on data availability when a training condition data user is specified.</p> RETURNS DESCRIPTION <code>bool</code> <p>True if training can be executed, False otherwise.</p> Source code in <code>src/pamiq_core/trainer/base.py</code> <pre><code>def is_trainable(self) -&gt; bool:\n    \"\"\"Determines if the training can be executed.\n\n    Checks if training can proceed based on data availability when\n    a training condition data user is specified.\n\n    Returns:\n        True if training can be executed, False otherwise.\n    \"\"\"\n    # If no data user is specified for condition checking, always trainable\n    if self._training_condition_data_user is None:\n        return True\n\n    data_user = self.get_data_user(self._training_condition_data_user)\n    data_user.update()\n\n    trainable = (\n        len(data_user) &gt;= self._min_buffer_size\n        and data_user.count_data_added_since(self._previous_training_time)\n        &gt;= self._min_new_data_count\n    )\n\n    if trainable:\n        self._previous_training_time = time.time()\n\n    return trainable\n</code></pre>"},{"location":"api/trainer/#pamiq_core.trainer.Trainer.setup","title":"setup","text":"<pre><code>setup() -&gt; None\n</code></pre> <p>Setup procedure before training starts.</p> Source code in <code>src/pamiq_core/trainer/base.py</code> <pre><code>def setup(self) -&gt; None:\n    \"\"\"Setup procedure before training starts.\"\"\"\n    pass\n</code></pre>"},{"location":"api/trainer/#pamiq_core.trainer.Trainer.train","title":"train  <code>abstractmethod</code>","text":"<pre><code>train() -&gt; None\n</code></pre> <p>Train models.</p> <p>Please build the models, optimizers, dataset, and other components in this method. This method is called repeatedly.</p> <p>After this method, :meth:<code>sync_models</code> to be called.</p> Source code in <code>src/pamiq_core/trainer/base.py</code> <pre><code>@abstractmethod\ndef train(self) -&gt; None:\n    \"\"\"Train models.\n\n    Please build the models, optimizers, dataset, and other components in this method.\n    This method is called repeatedly.\n\n    After this method, :meth:`sync_models` to be called.\n    \"\"\"\n</code></pre>"},{"location":"api/trainer/#pamiq_core.trainer.Trainer.sync_models","title":"sync_models","text":"<pre><code>sync_models() -&gt; None\n</code></pre> <p>Synchronizes params of trained models to inference models.</p> Source code in <code>src/pamiq_core/trainer/base.py</code> <pre><code>def sync_models(self) -&gt; None:\n    \"\"\"Synchronizes params of trained models to inference models.\"\"\"\n    for name in self._retrieved_model_names:\n        self._training_models[name].sync()\n</code></pre>"},{"location":"api/trainer/#pamiq_core.trainer.Trainer.teardown","title":"teardown","text":"<pre><code>teardown() -&gt; None\n</code></pre> <p>Teardown procedure after training.</p> Source code in <code>src/pamiq_core/trainer/base.py</code> <pre><code>def teardown(self) -&gt; None:\n    \"\"\"Teardown procedure after training.\"\"\"\n    pass\n</code></pre>"},{"location":"api/trainer/#pamiq_core.trainer.Trainer.run","title":"run","text":"<pre><code>run() -&gt; bool\n</code></pre> <p>Runs the training process if the trainer is trainable.</p> RETURNS DESCRIPTION <code>bool</code> <p>True if training was executed, False if skipped due to conditions not met.</p> <p> TYPE: <code>bool</code> </p> Source code in <code>src/pamiq_core/trainer/base.py</code> <pre><code>def run(self) -&gt; bool:\n    \"\"\"Runs the training process if the trainer is trainable.\n\n    Returns:\n        bool: True if training was executed, False if skipped due to conditions not met.\n    \"\"\"\n    if not self.is_trainable():\n        return False\n\n    self.setup()\n    self.train()\n    self.sync_models()\n    self.teardown()\n    return True\n</code></pre>"},{"location":"api/trainer/#pamiq_core.trainer.Trainer.save_state","title":"save_state","text":"<pre><code>save_state(path: Path) -&gt; None\n</code></pre> <p>Save the trainer state to the specified path.</p> PARAMETER DESCRIPTION <code>path</code> <p>Directory path where to save the trainer state.</p> <p> TYPE: <code>Path</code> </p> Source code in <code>src/pamiq_core/trainer/base.py</code> <pre><code>@override\ndef save_state(self, path: Path) -&gt; None:\n    \"\"\"Save the trainer state to the specified path.\n\n    Args:\n        path: Directory path where to save the trainer state.\n    \"\"\"\n    path.mkdir()\n    (path / \"previous_training_time\").write_text(\n        str(self._previous_training_time), encoding=\"utf-8\"\n    )\n</code></pre>"},{"location":"api/trainer/#pamiq_core.trainer.Trainer.load_state","title":"load_state","text":"<pre><code>load_state(path: Path) -&gt; None\n</code></pre> <p>Load the trainer state from the specified path.</p> PARAMETER DESCRIPTION <code>path</code> <p>Directory path from where to load the trainer state.</p> <p> TYPE: <code>Path</code> </p> Source code in <code>src/pamiq_core/trainer/base.py</code> <pre><code>@override\ndef load_state(self, path: Path) -&gt; None:\n    \"\"\"Load the trainer state from the specified path.\n\n    Args:\n        path: Directory path from where to load the trainer state.\n    \"\"\"\n    self._previous_training_time = float(\n        (path / \"previous_training_time\").read_text(\"utf-8\")\n    )\n</code></pre>"},{"location":"user-guide/","title":"Overview","text":"<p>This document describes information for working with PAMIQ-Core. Let\u2019s walk through the sections that might catch your interest.</p>"},{"location":"user-guide/#user-guide-structure","title":"User Guide Structure","text":"<ul> <li>Launch: System setup and startup</li> <li>Console: Interactive CUI and external system control</li> <li>Interaction: Interface between agent and environment</li> <li>Model: Model implementation and management</li> <li>Data: Data buffers and memory management</li> <li>Trainer: Training loop and algorithms</li> <li>Torch\ud83d\udd25: PyTorch integration</li> <li>State Persistence: Saving and restoring system state</li> <li>Schedulers: Management of periodic task execution</li> <li>Test: Testing guide for PAMIQ-Core framework.</li> </ul>"},{"location":"user-guide/console/","title":"Console","text":"<p>The <code>console</code> module provides the interactive command-line interface. It can control PAMIQ-Core system externally.</p>"},{"location":"user-guide/console/#pamiq-console","title":"PAMIQ Console","text":"<p>After launching a PAMIQ-Core system, you can connect to it using the <code>pamiq-console</code> command-line tool:</p> <pre><code>$ pamiq-console\nWelcome to the PAMIQ console. \"help\" lists commands.\n\npamiq-console (active) &gt;\n</code></pre> <p>The console prompt shows the current system state (e.g., <code>active</code>, <code>paused</code>, <code>shutting down</code>) in parentheses.</p>"},{"location":"user-guide/console/#available-commands","title":"Available Commands","text":"<ul> <li><code>h</code> or <code>help</code> - Show all available commands and their descriptions</li> <li><code>p</code> or <code>pause</code> - Pause the system</li> <li><code>r</code> or <code>resume</code> - Resume the system</li> <li><code>save</code> - Save a checkpoint of the current system state</li> <li><code>shutdown</code> - Shutdown the system (requires confirmation)</li> <li><code>q</code> or <code>quit</code> - Exit the console (does not affect the running system)</li> </ul>"},{"location":"user-guide/console/#launch-options","title":"Launch Options","text":"<p>The <code>pamiq-console</code> command accepts the following options:</p> <ul> <li><code>--host</code>: Hostname or IP address of the PAMIQ system (default: localhost)</li> <li><code>--port</code>: Port number for the web API connection (default: 8391)</li> </ul> <p>Example with custom connection settings:</p> <pre><code>$ pamiq-console --host 192.168.1.100 --port 9000\n</code></pre> <p>NOTE: You can modify the default address used by the system by changing the <code>web_api_address</code> parameter in LaunchConfig.</p>"},{"location":"user-guide/console/#web-api","title":"Web API","text":"<p>PAMIQ-Core exposes a RESTful API that allows controlling the system over a network connection. This enables integration with external applications, monitoring tools, or custom interfaces.</p>"},{"location":"user-guide/console/#api-endpoints","title":"API Endpoints","text":"<ul> <li><code>GET /api/status</code> - Retrieve the current system status</li> <li><code>POST /api/pause</code> - Pause the system</li> <li><code>POST /api/resume</code> - Resume the system</li> <li><code>POST /api/shutdown</code> - Shutdown the system</li> <li><code>POST /api/save-state</code> - Save the current system state</li> </ul>"},{"location":"user-guide/console/#example-api-usage","title":"Example API Usage","text":"<p>Using <code>curl</code> to interact with the API:</p> <pre><code># Get current status\ncurl http://localhost:8391/api/status\n\n# Pause the system\ncurl -X POST http://localhost:8391/api/pause\n\n# Save current state\ncurl -X POST http://localhost:8391/api/save-state\n</code></pre> <p>Response format is JSON, for example:</p> <pre><code>{\"status\": \"active\"}  // For status endpoint\n{\"result\": \"ok\"}      // For action endpoints\n</code></pre>"},{"location":"user-guide/console/#system-status","title":"System Status","text":"<p>The status endpoint returns one of the following values:</p> <ul> <li><code>active</code> - System is running normally</li> <li><code>pausing</code> - System is in the process of pausing</li> <li><code>paused</code> - System is fully paused</li> <li><code>resuming</code> - System is in the process of resuming</li> <li><code>shutting down</code> - System is shutting down</li> </ul>"},{"location":"user-guide/console/#keyboard-shortcut-controller","title":"Keyboard Shortcut Controller","text":"<p>PAMIQ-Core provides a keyboard shortcut controller. Users can pause/resume a agent by keyboard shortcuts.</p>"},{"location":"user-guide/console/#default-shortcuts","title":"Default Shortcuts","text":"<ul> <li>Windows/Linux: <code>Alt+Shift+P</code> (Pause) and <code>Alt+Shift+R</code> (Resume)</li> <li>macOS: <code>Option+Shift+P</code> (Pause) and <code>Option+Shift+R</code> (Resume)</li> <li>Windows also supports <code>Alt+Shift+Q</code> to quit the controller</li> </ul>"},{"location":"user-guide/console/#installation","title":"Installation","text":"<pre><code>pip install pamiq-core[kbctl]\n</code></pre> <p>Note for Linux users: The following dependencies may be required:</p> <pre><code>sudo apt-get install libevdev-dev build-essential\n</code></pre>"},{"location":"user-guide/console/#usage","title":"Usage","text":"<pre><code>pamiq-kbctl\n</code></pre>"},{"location":"user-guide/console/#macos-accessibility-permissions","title":"macOS Accessibility Permissions","text":"<p>On macOS, you must grant Accessibility permissions to your terminal application before using <code>pamiq-kbctl</code>:</p> <ol> <li>Go to System Settings \u2192 Privacy &amp; Security \u2192 Accessibility</li> <li>Click the \"+\" button</li> <li>Add your terminal application (Terminal, iTerm2, VS Code Terminal, etc.)</li> <li>Restart your terminal application after granting permissions</li> </ol> <p>Without these permissions, macOS will prevent keyboard monitoring and <code>pamiq-kbctl</code> will not function properly.</p>"},{"location":"user-guide/console/#command-line-options","title":"Command-line Options","text":"<ul> <li><code>--host</code>: Hostname of the PAMIQ system (default: localhost)</li> <li><code>--port</code>: Port number for the web API (default: 8391)</li> <li><code>--pause-key</code>: Custom key combination for pause</li> <li><code>--resume-key</code>: Custom key combination for resume</li> <li><code>--quit-key</code>: Custom key combination to exit the controller</li> </ul> <p>Example with custom shortcuts:</p> <pre><code>pamiq-kbctl --pause-key \"ctrl+p\" --resume-key \"ctrl+r\"\n</code></pre>"},{"location":"user-guide/console/#api-reference","title":"API Reference","text":"<p>For detailed information about the classes and methods in the console module, check out the API Reference.</p>"},{"location":"user-guide/data/","title":"Data","text":"<p>The <code>data</code> module provides functionality for collecting, storing, and managing data needed for training models. It enables efficient data flow between inference and training threads, ensuring that learning can happen continuously during agent-environment interactions.</p>"},{"location":"user-guide/data/#basic-concepts","title":"Basic Concepts","text":"<p>PAMIQ-Core's data system is built around three key components:</p> <ol> <li>DataBuffer: Stores and manages collected data samples</li> <li>DataCollector: Provides an interface for collecting data in the inference thread</li> <li>DataUser: Provides an interface for accessing collected data in the training thread</li> </ol> <p>These components work together to create a thread-safe data pipeline:</p> <pre><code>DataCollector in Agent (inference thread)\n\u2193\nDataBuffer\n\u2191\nDataUser in Trainer (training thread)\n</code></pre>"},{"location":"user-guide/data/#data-flow-architecture","title":"Data Flow Architecture","text":""},{"location":"user-guide/data/#datacollector","title":"DataCollector","text":"<p>The <code>DataCollector</code> provides a thread-safe interface for collecting data in the inference thread:</p> <pre><code>from pamiq_core import Agent\nfrom typing import override\n\nclass DataCollectingAgent(Agent[float, int]):\n    \"\"\"An agent that collects experience data during inference.\"\"\"\n\n    @override\n    def on_data_collectors_attached(self) -&gt; None:\n        \"\"\"Called when data collectors are attached to the agent.\"\"\"\n        self.experience_collector = self.get_data_collector(\"experience\")\n\n    @override\n    def step(self, observation: float) -&gt; int:\n        \"\"\"Process observation and decide on action.\"\"\"\n        # Make a decision\n        action = int(observation &gt; 0)\n\n        # Collect experience data\n        self.experience_collector.collect({\n            \"observation\": observation,\n            \"action\": action,\n            \"reward\": 1.0 if action == 1 else -1.0\n        })\n\n        return action\n</code></pre> <p>The <code>collect</code> method adds a single step's data to an internal queue. This data is later transferred to the data buffer when <code>update</code> is called.</p>"},{"location":"user-guide/data/#datauser","title":"DataUser","text":"<p>The <code>DataUser</code> provides access to collected data in the training thread:</p> <pre><code>from pamiq_core import Trainer\nfrom typing import override\n\nclass ExperienceTrainer(Trainer):\n    \"\"\"A trainer that uses collected experience data.\"\"\"\n\n    @override\n    def on_data_users_attached(self) -&gt; None:\n        \"\"\"Called when data users are attached to the trainer.\"\"\"\n        self.experience_data = self.get_data_user(\"experience\")\n\n    @override\n    def train(self) -&gt; None:\n        \"\"\"Train models using collected data.\"\"\"\n        # Update to transfer collected data from collectors to buffer\n        self.experience_data.update()\n\n        # Get the latest data\n        data = self.experience_data.get_data()\n\n        # Use the data for training\n        observations = data[\"observation\"]\n        actions = data[\"action\"]\n        rewards = data[\"reward\"]\n\n        print(f\"Training on {len(observations)} samples\")\n        # ... (training logic)\n</code></pre> <p>The <code>update</code> method transfers data from the collector's queue to the buffer, making it available for training.</p>"},{"location":"user-guide/data/#implementing-custom-databuffers","title":"Implementing Custom DataBuffers","text":"<p>You can implement custom data buffers to handle specific data storage requirements. A data buffer must implement three key methods:</p> <ol> <li><code>add</code>: Add a new data sample</li> <li><code>get_data</code>: Retrieve all stored data</li> <li><code>__len__</code>: Return the current number of samples</li> </ol> <p>Here's an example of a simple custom buffer:</p> <pre><code>from pamiq_core.data import DataBuffer\nfrom typing import override\n\nclass SimpleBuffer[T](DataBuffer[T]):\n    \"\"\"A simple buffer that stores data in lists.\"\"\"\n\n    @override\n    def __init__(self, collecting_data_names: list[str], max_size: int) -&gt; None:\n        \"\"\"Initialize the buffer.\n\n        Args:\n            collecting_data_names: Names of data fields to collect\n            max_size: Maximum number of samples to store\n        \"\"\"\n        super().__init__(collecting_data_names, max_size)\n        self._data = {name: [] for name in collecting_data_names}\n        self._count = 0\n\n    @override\n    def add(self, step_data: dict[str, T]) -&gt; None:\n        \"\"\"Add a new data sample to the buffer.\n\n        Args:\n            step_data: Dictionary containing data for one step\n        \"\"\"\n        # Verify all required fields are present\n        for name in self._collecting_data_names:\n            if name not in step_data:\n                raise KeyError(f\"Required data '{name}' not found in step_data\")\n\n        # Add data to buffer\n        if self._count &lt; self.max_size:\n            for name in self._collecting_data_names:\n                self._data[name].append(step_data[name])\n            self._count += 1\n        else:\n            # Replace oldest data (index 0)\n            for name in self._collecting_data_names:\n                self._data[name].pop(0)\n                self._data[name].append(step_data[name])\n\n    @override\n    def get_data(self) -&gt; dict[str, list[T]]:\n        \"\"\"Retrieve all stored data from the buffer.\n\n        Returns:\n            Dictionary mapping data field names to lists of values\n        \"\"\"\n        return {name: data.copy() for name, data in self._data.items()}\n\n    @override\n    def __len__(self) -&gt; int:\n        \"\"\"Return the current number of samples in the buffer.\n\n        Returns:\n            Number of samples currently stored\n        \"\"\"\n        return self._count\n</code></pre>"},{"location":"user-guide/data/#built-in-databuffers","title":"Built-in DataBuffers","text":"<p>PAMIQ-Core provides several pre-implemented data buffers to handle common use cases:</p>"},{"location":"user-guide/data/#sequentialbuffer","title":"SequentialBuffer","text":"<p>The <code>SequentialBuffer</code> stores data in sequence and discards the oldest data when the buffer reaches its maximum size:</p> <pre><code>from pamiq_core.data.impls import SequentialBuffer\n\n# Create a buffer for state, action, and reward data with max size 1000\nbuffer = SequentialBuffer([\"state\", \"action\", \"reward\"], max_size=1000)\n\n# Add data\nbuffer.add({\"state\": [0.1, 0.2], \"action\": 1, \"reward\": 0.5})\n\n# Get all data\ndata = buffer.get_data()\n</code></pre> <p>This buffer is useful for:</p> <ul> <li>Experience replay in reinforcement learning</li> <li>Training on the most recent experiences</li> <li>Sequential data processing</li> </ul>"},{"location":"user-guide/data/#randomreplacementbuffer","title":"RandomReplacementBuffer","text":"<p>The <code>RandomReplacementBuffer</code> fills up to its maximum size and then randomly replaces existing samples with a configurable probability:</p> <pre><code>from pamiq_core.data.impls import RandomReplacementBuffer\n\n# Create a buffer with 80% replacement probability\nbuffer = RandomReplacementBuffer(\n    [\"state\", \"action\", \"reward\"],\n    max_size=1000,\n    replace_probability=0.8\n)\n</code></pre> <p>This buffer is useful for:</p> <ul> <li>Maintaining diversity in training data</li> <li>Preserving rare or important samples</li> <li>Balancing between old and new experiences</li> </ul> <p>The detailed characteristics of this buffer type are discussed in this article.</p>"},{"location":"user-guide/data/#thread-safety-considerations","title":"Thread Safety Considerations","text":"<p>The data system in PAMIQ-Core is designed to be thread-safe, with several important mechanisms:</p> <ol> <li>Collector Acquisition: Data collectors must be acquired before use, ensuring they can only be accessed by one component at a time</li> <li>Queue-based Transfer: Data is transferred between threads using thread-safe queues</li> <li>Lock Protection: Critical sections are protected by locks to prevent race conditions</li> </ol>"},{"location":"user-guide/data/#api-reference","title":"API Reference","text":"<p>More details, Checkout to the API Reference</p>"},{"location":"user-guide/interaction/","title":"Interaction","text":"<p>The <code>interaction</code> module defines interfaces for agents and environments, and manages the data flow between them. This module provides the foundation for building intelligent systems that can interact with their surroundings.</p>"},{"location":"user-guide/interaction/#agent-implementation","title":"Agent Implementation","text":"<p>Agents process observations from the environment and decide on actions to take. To implement a custom agent, you need to:</p> <ol> <li>Define the observation and action types</li> <li>Override the <code>step</code> method to process observations and return actions</li> </ol> <pre><code>from pamiq_core import Agent\nfrom typing import override\n\nclass MyAgent(Agent[list[float], int]):\n    \"\"\"Custom agent that processes observations as float lists and outputs integer actions.\"\"\"\n\n    @override\n    def step(self, observation: list[float]) -&gt; int:\n        \"\"\"Process observation and decide on an action.\n\n        Args:\n            observation: Current observation from environment\n\n        Returns:\n            The chosen action\n        \"\"\"\n        # Simple decision logic based on observation\n        if sum(observation) &gt; 0:\n            return 1\n        else:\n            return 0\n</code></pre>"},{"location":"user-guide/interaction/#composite-agents","title":"Composite Agents","text":"<p>Agents can contain child agents that share the parent's inference models and data collectors. This is useful for building hierarchical decision-making systems or dividing complex agent logic into modular components:</p> <pre><code>from pamiq_core import Agent\n\nclass MainAgent(Agent[..., ...]):\n    @override\n    def __init__(self) -&gt; None:\n        # Create child agents\n        self.navigation_agent = NavigationAgent()\n        self.perception_agent = PerceptionAgent()\n        self.planning_agent = PlanningAgent()\n\n        # Create parent agent with child agents\n        super().__init__(agents={\n            \"navigation\": self.navigation_agent,\n            \"perception\": self.perception_agent,\n            \"planning\": self.planning_agent\n        })\n</code></pre> <p>When models and data collectors are attached to the parent agent, they are automatically propagated to all child agents. Similarly, system events like pause and resume are also forwarded to all child agents, ensuring consistent state across the hierarchy. State persistence is handled hierarchically as well, with each child agent's state being saved and loaded as part of the parent's state.</p>"},{"location":"user-guide/interaction/#accessing-inference-models","title":"Accessing Inference Models","text":"<p>To access inference models for decision making, override the <code>on_inference_models_attached</code> callback:</p> <pre><code>@override\ndef on_inference_models_attached(self) -&gt; None:\n    \"\"\"Called when inference models are attached to the agent.\"\"\"\n    self.policy_model = self.get_inference_model(\"policy\")\n    self.value_model = self.get_inference_model(\"value\")\n</code></pre> <p>This callback is executed when the system attaches the models you provided to the <code>launch</code> function.</p>"},{"location":"user-guide/interaction/#collecting-experience-data","title":"Collecting Experience Data","text":"<p>To collect data for training, override the <code>on_data_collectors_attached</code> callback:</p> <pre><code>@override\ndef on_data_collectors_attached(self) -&gt; None:\n    \"\"\"Called when data collectors are attached to the agent.\"\"\"\n    self.experience_collector = self.get_data_collector(\"experience\")\n\n@override\ndef step(self, observation: list[float]) -&gt; int:\n    # Use the model for decision making\n    action = self.policy_model(observation)\n\n    # Collect experience for training\n    self.experience_collector.collect({\n        \"observation\": observation,\n        \"action\": action\n    })\n\n    return action\n</code></pre>"},{"location":"user-guide/interaction/#environment-implementation","title":"Environment Implementation","text":"<p>Environments provide observations to agents and receive actions. To implement a custom environment:</p> <pre><code>from pamiq_core import Environment\nfrom typing import override\n\nclass MyEnvironment(Environment[list[float], int]):\n    \"\"\"Custom environment that provides float list observations and accepts integer actions.\"\"\"\n\n    def __init__(self):\n        self.state = [0.0, 0.0, 0.0]\n\n    @override\n    def observe(self) -&gt; list[float]:\n        \"\"\"Return the current observation.\n\n        Returns:\n            Current environment state as observation\n        \"\"\"\n        return self.state.copy()\n\n    @override\n    def affect(self, action: int) -&gt; None:\n        \"\"\"Apply the action to change the environment state.\n\n        Args:\n            action: Action to apply to the environment\n        \"\"\"\n        # Simple environment dynamics\n        if action == 1:\n            self.state[0] += 0.1\n        else:\n            self.state[0] -= 0.1\n</code></pre>"},{"location":"user-guide/interaction/#interaction-class","title":"Interaction Class","text":"<p>The <code>Interaction</code> class connects an agent and environment, implementing the core interaction loop:</p> <pre><code>from pamiq_core import Interaction, Agent, Environment\n\n# Create agent and environment\nagent = MyAgent()\nenvironment = MyEnvironment()\n\n# Create interaction\ninteraction = Interaction(agent, environment)\n\n# Manual stepping (normally handled by the system)\ninteraction.setup()\nfor _ in range(10):\n    interaction.step()  # Performs observe-think-act cycle\ninteraction.teardown()\n</code></pre>"},{"location":"user-guide/interaction/#fixed-interval-interaction","title":"Fixed Interval Interaction","text":"<p>For real-time systems, you often need to maintain a consistent timing for the interaction loop. The <code>FixedIntervalInteraction</code> class provides this functionality:</p> <pre><code>from pamiq_core import FixedIntervalInteraction\n\n# Create a fixed interval interaction running at 10Hz (every 0.1 seconds)\ninteraction = FixedIntervalInteraction.with_sleep_adjustor(\n    agent,\n    environment,\n    interval=0.1\n)\n</code></pre> <p>The <code>with_sleep_adjustor</code> factory method is the most common way to create a fixed interval interaction, as it uses CPU sleep to maintain timing.</p>"},{"location":"user-guide/interaction/#modular-environment","title":"Modular Environment","text":"<p>The <code>ModularEnvironment</code> class breaks down environment functionality into sensor and actuator components:</p> <pre><code>from pamiq_core import ModularEnvironment, Sensor, Actuator\nfrom typing import override\n\nclass CameraSensor(Sensor[list[float]]):\n    @override\n    def read(self) -&gt; list[float]:\n        \"\"\"Read camera data.\"\"\"\n        # Code to capture and process image\n        return [0.1, 0.2, 0.3]  # Processed image features\n\nclass MotorActuator(Actuator[int]):\n    @override\n    def operate(self, action: int) -&gt; None:\n        \"\"\"Control motors based on action.\"\"\"\n        # Code to control motors\n        print(f\"Moving motors with command {action}\")\n\n# Create modular environment\nenvironment = ModularEnvironment(CameraSensor(), MotorActuator())\n</code></pre> <p>This approach enables reusable components and cleaner separation of concerns.</p>"},{"location":"user-guide/interaction/#composite-sensors-and-actuators","title":"Composite Sensors and Actuators","text":"<p>ModularEnvironment provides mechanisms for handling multiple sensors and actuators together, enhancing flexibility:</p> <pre><code>from pamiq_core import ModularEnvironment, SensorsDict, ActuatorsDict\n\n# Combine multiple sensors\nsensors = SensorsDict({\n    \"camera\": CameraSensor(),\n    \"lidar\": LidarSensor(),\n    \"temperature\": TemperatureSensor()\n})\n\n# Combine multiple actuators\nactuators = ActuatorsDict({\n    \"motor\": MotorActuator(),\n    \"gripper\": GripperActuator(),\n    \"speaker\": SpeakerActuator()\n})\n\n# Create environment with composite sensor and actuator\nenvironment = ModularEnvironment(sensors, actuators)\n</code></pre> <p>With this approach, sensor readings are returned as a dictionary with sensor names as keys, and actions are passed as dictionaries with actuator names as keys.</p> <pre><code># Example observation\nobservation = environment.observe()\n# Result: {\"camera\": [...], \"lidar\": [...], \"temperature\": 22.5}\n\n# Example action\naction = {\n    \"motor\": 0.5,       # Run motor at 50% speed\n    \"gripper\": \"close\", # Close the gripper\n    \"speaker\": \"beep\"   # Play a beep sound\n}\nenvironment.affect(action)\n</code></pre>"},{"location":"user-guide/interaction/#convenient-factory-method","title":"Convenient Factory Method","text":"<p>ModularEnvironment also provides a factory method to simplify creating environments with composite sensors and actuators:</p> <pre><code># Create ModularEnvironment directly from dictionaries\nenvironment = ModularEnvironment.from_dict(\n    sensors={\n        \"camera\": CameraSensor(),\n        \"lidar\": LidarSensor()\n    },\n    actuators={\n        \"motor\": MotorActuator(),\n        \"gripper\": GripperActuator()\n    }\n)\n</code></pre> <p>This approach allows you to modularize complex environments by component, enhancing reusability and extensibility.</p>"},{"location":"user-guide/interaction/#wrappers","title":"Wrappers","text":"<p>Wrappers transform data flowing between components. PAMIQ-Core provides wrappers for environments, sensors, and actuators:</p> <pre><code>from pamiq_core import EnvironmentWrapper\n\n# Create a wrapper to normalize observations\ndef normalize_observation(obs: list[float]) -&gt; list[float]:\n    return [x / 10.0 for x in obs]\n\n# Create a wrapper to scale actions\ndef scale_action(action: int) -&gt; int:\n    return action * 2\n\n# Wrap the environment\nwrapped_env = EnvironmentWrapper(\n    environment,\n    obs_wrapper=normalize_observation,\n    act_wrapper=scale_action,\n)\n</code></pre> <p>For more complex transformations, you can create a custom wrapper:</p> <pre><code>from pamiq_core import Wrapper\nfrom typing import override\n\nclass ImageProcessingWrapper(Wrapper[list[float], list[float]]):\n    @override\n    def wrap(self, image: list[float]) -&gt; list[float]:\n        \"\"\"Apply image processing transformations.\"\"\"\n        # Complex image processing logic\n        return [x * 0.5 + 0.1 for x in image]\n</code></pre>"},{"location":"user-guide/interaction/#sensor-and-actuator-wrappers","title":"Sensor and Actuator Wrappers","text":"<p>In addition to wrapping entire environments, you can wrap individual sensors and actuators:</p> <pre><code>from pamiq_core import SensorWrapper, ActuatorWrapper\n\n# Wrap a sensor to process its readings\nsensor_wrapper = SensorWrapper(camera_sensor, normalize_observation)\n\n# Wrap an actuator to transform actions before they reach it\nactuator_wrapper = ActuatorWrapper(motor_actuator, scale_action)\n</code></pre> <p>These wrappers work similarly to <code>EnvironmentWrapper</code> but operate at the component level:</p> <ul> <li><code>SensorWrapper</code> transforms the output from a sensor after reading</li> <li><code>ActuatorWrapper</code> transforms the input to an actuator before operating</li> </ul>"},{"location":"user-guide/interaction/#wrapper-helper-methods","title":"Wrapper Helper Methods","text":"<p>Wrapper instances provide convenient helper methods to directly create sensor and actuator wrappers:</p> <pre><code># Create an image processing wrapper\nimage_processor = ImageProcessingWrapper()\n\n# Apply the wrapper to a sensor\nprocessed_camera = image_processor.wrap_sensor(camera_sensor)\n\n# Apply the inverse of the wrapper to an actuator\nprocessed_motor = image_processor.wrap_actuator(motor_actuator)\n</code></pre>"},{"location":"user-guide/interaction/#common-event-hooks","title":"Common Event Hooks","text":"<p>PAMIQ-Core components have common event hooks that you can override:</p>"},{"location":"user-guide/interaction/#interaction-events","title":"Interaction Events","text":"<pre><code>@override\ndef setup(self) -&gt; None:\n    \"\"\"Called when the interaction starts.\"\"\"\n    super().setup()  # Always call the parent method\n    print(\"Setting up resources...\")\n\n@override\ndef teardown(self) -&gt; None:\n    \"\"\"Called when the interaction ends.\"\"\"\n    super().teardown()  # Always call the parent method\n    print(\"Cleaning up resources...\")\n</code></pre>"},{"location":"user-guide/interaction/#thread-events","title":"Thread Events","text":"<pre><code>@override\ndef on_paused(self) -&gt; None:\n    \"\"\"Called when the system is paused.\"\"\"\n    super().on_paused()  # Always call the parent method\n    print(\"System paused, suspending external connections...\")\n\n@override\ndef on_resumed(self) -&gt; None:\n    \"\"\"Called when the system is resumed.\"\"\"\n    super().on_resumed()  # Always call the parent method\n    print(\"System resumed, restoring external connections...\")\n</code></pre> <p>These event hooks enable proper lifecycle management and allow components to respond to system state changes.</p>"},{"location":"user-guide/interaction/#api-reference","title":"API Reference","text":"<p>More details, Checkout to the API Reference</p>"},{"location":"user-guide/launch/","title":"Launch","text":"<p>The <code>launch</code> function is the entry point for starting a PAMIQ-Core system. It initializes all components, connects them together, and manages the system's lifecycle.</p>"},{"location":"user-guide/launch/#basic-usage","title":"Basic Usage","text":"<p>To launch a PAMIQ-Core system, you need to provide your interaction components, models, data buffers, trainers, and configuration settings:</p> <pre><code>from pamiq_core import launch, LaunchConfig, Interaction\n\n# Create your agent and environment\nagent = YourAgent()\nenvironment = YourEnvironment()\n\n# Create an interaction between them\ninteraction = Interaction(agent, environment)\n\n# Launch the system\nlaunch(\n    interaction=interaction,\n    models={\"model_name\": your_model},\n    data={\"buffer_name\": your_data_buffer},\n    trainers={\"trainer_name\": your_trainer},\n    config=LaunchConfig(\n        states_dir=\"./saved_states\",\n        max_uptime=3600,  # Run for 1 hour\n        time_scale=2.0    # Run at 2x speed\n    )\n)\n</code></pre>"},{"location":"user-guide/launch/#common-configuration-scenarios","title":"Common Configuration Scenarios","text":""},{"location":"user-guide/launch/#accelerated-learning","title":"Accelerated Learning","text":"<p>To speed up time for faster training:</p> <pre><code>config = LaunchConfig(\n    time_scale=10.0,  # Run at 10x speed\n    save_state_interval=300.0  # Save every 5 minutes\n)\n</code></pre>"},{"location":"user-guide/launch/#resumable-training","title":"Resumable Training","text":"<p>To save system state for later resumption:</p> <pre><code># Initial run\nlaunch(\n    interaction=interaction,\n    models=models,\n    data=data,\n    trainers=trainers,\n    config=LaunchConfig(\n        states_dir=\"./saved_states\",\n        save_state_interval=600.0  # Save every 10 minutes\n    )\n)\n\n# Later, resume from the last saved state\nlatest_state = list(Path(\"./saved_states\").glob(\"*.state\"))[-1]\nlaunch(\n    interaction=interaction,\n    models=models,\n    data=data,\n    trainers=trainers,\n    config=LaunchConfig(\n        states_dir=\"./saved_states\",\n        saved_state_path=latest_state\n    )\n)\n</code></pre>"},{"location":"user-guide/launch/#api-reference","title":"API Reference","text":"<p>More details, Checkout to the API Reference</p>"},{"location":"user-guide/model/","title":"Model","text":"<p>The <code>model</code> module in PAMIQ-Core defines the interfaces for inference and training models, providing a framework for managing model synchronization in a multi-threaded environment. This allows inference to run continuously while training occurs in the background.</p>"},{"location":"user-guide/model/#basic-concepts","title":"Basic Concepts","text":"<p>PAMIQ-Core uses two distinct model representations:</p> <ol> <li>InferenceModel: Used for making predictions in the inference thread</li> <li>TrainingModel: Used for training in the training thread</li> </ol> <p>These two models are synchronized after training, allowing the inference model to benefit from ongoing training without interrupting the agent's decision-making process.</p>"},{"location":"user-guide/model/#implementing-custom-models","title":"Implementing Custom Models","text":""},{"location":"user-guide/model/#inferencemodel","title":"InferenceModel","text":"<p>The <code>InferenceModel</code> interface defines models that can be used for inference in the agent's decision-making process:</p> <pre><code>from pamiq_core import InferenceModel\nfrom typing import override\n\nclass MyInferenceModel(InferenceModel):\n    \"\"\"A simple custom inference model.\"\"\"\n\n    def __init__(self, weights: list[float]):\n        self.weights = weights\n\n    @override\n    def infer(self, features: list[float]) -&gt; float:\n        \"\"\"Make a prediction using the model.\n\n        Args:\n            features: Input features for inference\n\n        Returns:\n            Prediction result\n        \"\"\"\n        return sum(w * x for w, x in zip(self.weights, features))\n</code></pre> <p>The key method to implement is <code>infer()</code>, which takes input data and returns the model's prediction.</p>"},{"location":"user-guide/model/#trainingmodel","title":"TrainingModel","text":"<p>The <code>TrainingModel</code> interface defines models that can be trained and synchronized with inference models:</p> <pre><code>from pamiq_core import TrainingModel, InferenceModel\nfrom typing import override\n\nclass MyTrainingModel(TrainingModel[MyInferenceModel]):\n    \"\"\"A simple custom training model.\"\"\"\n\n    def __init__(self):\n        super().__init__(has_inference_model=True, inference_thread_only=False)\n        self.weights = [0.5, 0.3, -0.2]\n\n    @override\n    def _create_inference_model(self) -&gt; MyInferenceModel:\n        \"\"\"Create a new inference model instance.\n\n        Returns:\n            A new inference model with current weights\n        \"\"\"\n        return MyInferenceModel(self.weights.copy)\n\n    @override\n    def forward(self, features: list[float]) -&gt; float:\n        \"\"\"Forward pass for training.\n\n        Args:\n            features: Input features\n\n        Returns:\n            Output of the model\n        \"\"\"\n        return sum(w * x for w, x in zip(self.weights, features))\n\n    @override\n    def sync_impl(self, inference_model: MyInferenceModel) -&gt; None:\n        \"\"\"Synchronize parameters from training model to inference model.\n\n        Args:\n            inference_model: Inference model to update\n        \"\"\"\n        inference_model.weights = self.weights.copy()\n</code></pre> <p>Key methods to implement:</p> <ul> <li><code>_create_inference_model()</code>: Creates a new inference model instance</li> <li><code>forward()</code>: Performs the forward pass during training</li> <li><code>sync_impl()</code>: Synchronizes parameters from the training model to the inference model</li> </ul>"},{"location":"user-guide/model/#configuration-options","title":"Configuration Options","text":"<p>The <code>TrainingModel</code> class takes two important configuration parameters:</p> <ul> <li> <p>has_inference_model (default: <code>True</code>): Determines whether the training model creates and manages an associated inference model.</p> <ul> <li>When <code>True</code>: The model will create an inference model that can be used in the inference thread</li> <li>When <code>False</code>: No inference model is created, and the model can only be used for training</li> </ul> </li> <li> <p>inference_thread_only (default: <code>False</code>): Determines how the model is used in the thread architecture.</p> <ul> <li>When <code>True</code>: The model is used only in the inference thread and not modified by training. This is useful for pre-trained models that don't need to be updated.</li> <li>When <code>False</code>: The model is used for both training and inference, with parameters synchronized between threads.</li> </ul> </li> </ul> <p>These two parameters cannot be set to <code>has_inference_model=False</code> and <code>inference_thread_only=True</code> simultaneously, as this would create a model that can't be used in either thread.</p>"},{"location":"user-guide/model/#model-synchronization","title":"Model Synchronization","text":"<p>PAMIQ-Core's training thread automatically synchronizes parameters between training and inference models:</p> <ol> <li>The training thread updates model parameters</li> <li>The <code>sync()</code> method is called after training</li> <li>This triggers <code>sync_impl()</code> to copy parameters to the inference model</li> <li>The inference thread continues using the updated model</li> </ol>"},{"location":"user-guide/model/#thread-safety","title":"Thread Safety","text":"<p>The model architecture in PAMIQ-Core ensures thread safety through careful parameter synchronization:</p> <ul> <li>Inference models are read-only in the inference thread</li> <li>Training models are modified only in the training thread</li> <li>Parameter copying happens through a controlled synchronization process</li> <li>Concurrent access to models is managed to prevent race conditions</li> </ul> <p>This design allows for continuous inference while training progresses in the background.</p>"},{"location":"user-guide/model/#pytorch-integration","title":"PyTorch Integration \ud83d\udd25","text":"<p>For deep learning models, PAMIQ-Core offers seamless integration with PyTorch through the <code>torch</code> submodule. This provides specialized implementations of <code>InferenceModel</code> and <code>TrainingModel</code> that handle PyTorch model synchronization efficiently.</p> <p>For more details on using PyTorch with PAMIQ-Core, see the PyTorch Integration Guide.</p>"},{"location":"user-guide/model/#api-reference","title":"API Reference","text":"<p>More details, Checkout to the API Reference</p>"},{"location":"user-guide/schedulers/","title":"Schedulers","text":"<p><code>utils.schedulers</code> in PAMIQ-Core are used to execute callbacks at specified intervals. They provide a flexible way to implement periodic actions such as model saving, metric logging, or resource cleanup.</p>"},{"location":"user-guide/schedulers/#base-scheduler","title":"Base Scheduler","text":"<p>The <code>Scheduler</code> abstract base class provides common functionality for all scheduler implementations:</p> <pre><code>from pamiq_core.utils.schedulers import Scheduler\n\nclass MyScheduler(Scheduler):\n    def __init__(self, callbacks=None):\n        super().__init__(callbacks)\n        self.ready = False\n\n    def is_available(self):\n        return self.ready\n\n    def update(self):\n        # Set ready to True when some condition is met\n        self.ready = check_condition()\n        # Call parent update which will execute callbacks if is_available() returns True\n        super().update()\n</code></pre> <p>The key components of a scheduler are:</p> <ol> <li>Callbacks: Functions to execute when the scheduler is triggered</li> <li>Availability Check: Determines when callbacks should be executed</li> <li>Update Method: Called regularly to check availability and execute callbacks when appropriate</li> </ol>"},{"location":"user-guide/schedulers/#time-interval-scheduler","title":"Time Interval Scheduler","text":"<p>The <code>TimeIntervalScheduler</code> executes callbacks at fixed time intervals:</p> <pre><code>from pamiq_core.utils.schedulers import TimeIntervalScheduler\n\n# Create a scheduler that executes callbacks every 60 seconds\ndef log_metrics():\n    print(\"Logging metrics...\")\n\nmetrics_scheduler = TimeIntervalScheduler(60.0, log_metrics)\n\n# In your main loop:\nwhile running:\n    # ... other code\n    metrics_scheduler.update()\n    # ... more code\n</code></pre> <p>This scheduler is useful for:</p> <ul> <li>Periodic saving of model checkpoints</li> <li>Regular logging of metrics</li> <li>Environment cleanup at fixed intervals</li> <li>Any task that should occur based on elapsed real time</li> </ul>"},{"location":"user-guide/schedulers/#step-interval-scheduler","title":"Step Interval Scheduler","text":"<p>The <code>StepIntervalScheduler</code> executes callbacks after a specified number of steps:</p> <pre><code>from pamiq_core.utils.schedulers import StepIntervalScheduler\n\n# Create a scheduler that executes callbacks every 100 steps\ndef evaluate_model():\n    print(\"Evaluating model performance...\")\n\neval_scheduler = StepIntervalScheduler(100, evaluate_model)\n\n# In your training loop:\nfor step in range(total_steps):\n    # ... training code\n    eval_scheduler.update()  # Will trigger every 100 calls\n    # ... more training code\n</code></pre> <p>This scheduler is useful for:</p> <ul> <li>Model evaluation at regular intervals during training</li> <li>Gradient accumulation in deep learning</li> <li>Periodic data sampling or augmentation</li> <li>Any task that should occur based on iteration count</li> </ul>"},{"location":"user-guide/schedulers/#registering-multiple-callbacks","title":"Registering Multiple Callbacks","text":"<p>You can register multiple callbacks with a single scheduler:</p> <pre><code>from pamiq_core.utils.schedulers import TimeIntervalScheduler\n\n# Create scheduler with initial callback\nscheduler = TimeIntervalScheduler(300.0, save_checkpoint)\n\n# Register additional callbacks\nscheduler.register_callback(log_performance)\nscheduler.register_callback(clean_memory)\n\n# All three callbacks will execute every 5 minutes\n</code></pre> <p>You can also remove callbacks when they are no longer needed:</p> <pre><code># Remove a specific callback\nscheduler.remove_callback(clean_memory)\n</code></pre>"},{"location":"user-guide/schedulers/#integration-with-pamiq-core-components","title":"Integration with PAMIQ-Core Components","text":"<p>Schedulers are used throughout PAMIQ-Core for various periodic tasks:</p> <pre><code>from pamiq_core.utils.schedulers import TimeIntervalScheduler\n\nclass MyTrainer(Trainer):\n    def __init__(self):\n        super().__init__()\n        # Create scheduler for model evaluation\n        self.eval_scheduler = TimeIntervalScheduler(\n            interval=300.0,  # Every 5 minutes\n            callbacks=self.evaluate_model\n        )\n\n    def train(self):\n        # Training code...\n        self.eval_scheduler.update()\n        # More training code...\n\n    def evaluate_model(self):\n        # Model evaluation logic\n        pass\n</code></pre>"},{"location":"user-guide/schedulers/#api-reference","title":"API Reference","text":"<p>More details, Checkout to the API Reference</p>"},{"location":"user-guide/state_persistence/","title":"State Persistence","text":"<p>State persistence is a core feature of PAMIQ-Core that allows saving and loading the system state at any point during its operation. This capability is essential for continual learning systems, allowing agents to resume operation from where they left off, recover from crashes, or transfer knowledge between sessions.</p>"},{"location":"user-guide/state_persistence/#basic-concepts","title":"Basic Concepts","text":"<p>All major components in PAMIQ-Core implement state persistence through the <code>PersistentStateMixin</code> interface, which provides two key methods:</p> <ul> <li><code>save_state(self, path: Path)</code>: Saves the component's state to the specified path</li> <li><code>load_state(self, path: Path)</code>: Loads the component's state from the specified path</li> </ul> <p>These methods are implemented across all user-facing components, including:</p> <ul> <li><code>Agent</code>, <code>Environment</code>, and related interaction module classes</li> <li><code>DataBuffer</code></li> <li><code>TrainingModel</code></li> <li><code>Trainer</code></li> </ul> <p>When you launch a PAMIQ-Core system, the state persistence mechanism is automatically configured, and states are saved at intervals specified in your <code>LaunchConfig</code>.</p>"},{"location":"user-guide/state_persistence/#custom-state-persistence","title":"Custom State Persistence","text":"<p>When implementing custom components, you can override the <code>save_state</code> and <code>load_state</code> methods to add your own state persistence logic:</p> <pre><code>from pathlib import Path\nfrom pamiq_core import Agent\nfrom typing import override\n\nclass MyCustomAgent(Agent[float, int]):\n    \"\"\"Custom agent with state persistence.\"\"\"\n\n    def __init__(self):\n        super().__init__()\n        self.episode_count = 0\n        self.total_reward = 0.0\n        self.learning_rate = 0.01\n\n    @override\n    def step(self, observation: float) -&gt; int:\n        \"\"\"Process observation and return action.\"\"\"\n        # Example decision logic\n        action = 1 if observation &gt; 0 else 0\n        return action\n\n    @override\n    def save_state(self, path: Path) -&gt; None:\n        \"\"\"Save custom agent state.\n\n        Args:\n            path: Directory path where to save the state\n        \"\"\"\n        # Always call parent method first to handle built-in state persistence\n        super().save_state(path)\n\n        # Create directory if it doesn't exist\n        path.mkdir(exist_ok=True)\n\n        # Save custom state variables\n        with open(path / \"episode_stats.txt\", \"w\") as f:\n            f.write(f\"episode_count: {self.episode_count}\\n\")\n            f.write(f\"total_reward: {self.total_reward}\\n\")\n            f.write(f\"learning_rate: {self.learning_rate}\\n\")\n\n    @override\n    def load_state(self, path: Path) -&gt; None:\n        \"\"\"Load custom agent state.\n\n        Args:\n            path: Directory path from where to load the state\n        \"\"\"\n        # Always call parent method first to handle built-in state persistence\n        super().load_state(path)\n\n        # Load custom state variables\n        try:\n            with open(path / \"episode_stats.txt\", \"r\") as f:\n                lines = f.readlines()\n                for line in lines:\n                    key, value = line.strip().split(\": \")\n                    if key == \"episode_count\":\n                        self.episode_count = int(value)\n                    elif key == \"total_reward\":\n                        self.total_reward = float(value)\n                    elif key == \"learning_rate\":\n                        self.learning_rate = float(value)\n        except FileNotFoundError:\n            # Handle case when loading from a state that doesn't have custom data\n            self.episode_count = 0\n            self.total_reward = 0.0\n            self.learning_rate = 0.01\n</code></pre>"},{"location":"user-guide/state_persistence/#state-directory-structure","title":"State Directory Structure","text":"<p>When PAMIQ-Core saves a state, it creates a directory with the following structure:</p> <pre><code>[timestamp].state/\n\u251c\u2500\u2500 interaction/\n\u2502   \u251c\u2500\u2500 agent/\n\u2502   \u2502   \u2514\u2500\u2500 ... (agent state files)\n\u2502   \u2514\u2500\u2500 environment/\n\u2502       \u2514\u2500\u2500 ... (environment state files)\n\u251c\u2500\u2500 models/\n\u2502   \u2514\u2500\u2500 ... (model state files)\n\u251c\u2500\u2500 data/\n\u2502   \u2514\u2500\u2500 ... (data buffer state files)\n\u251c\u2500\u2500 trainers/\n\u2502   \u2514\u2500\u2500 ... (trainer state files)\n\u2514\u2500\u2500 time.pkl (time controller state)\n</code></pre> <p>This organized structure makes it easy to inspect and manage saved states.</p>"},{"location":"user-guide/state_persistence/#state-management","title":"State Management","text":"<p>The state persistence system in PAMIQ-Core automatically manages state directories:</p> <ul> <li>States are saved at regular intervals as specified in the <code>LaunchConfig</code></li> <li>Old states can be automatically cleaned up based on the <code>max_keep_states</code> parameter</li> <li>States can be loaded during system launch using the <code>saved_state_path</code> parameter</li> </ul> <pre><code>from pamiq_core import launch, LaunchConfig\n\n# Launch with automatic state saving every 5 minutes, keeping the 10 most recent states\nlaunch(\n    interaction=interaction,\n    models=models,\n    data=data,\n    trainers=trainers,\n    config=LaunchConfig(\n        states_dir=\"./saved_states\",\n        save_state_interval=300.0,  # 5 minutes\n        max_keep_states=10\n    )\n)\n</code></pre>"},{"location":"user-guide/state_persistence/#thread-safety","title":"Thread Safety","text":"<p>The state persistence system is designed to be thread-safe:</p> <ul> <li>The <code>save_state</code> operation pauses all threads before saving to ensure consistency</li> <li>State saving and loading operations are coordinated by the control thread</li> <li>Components have appropriate synchronization mechanisms to handle concurrent access</li> </ul> <p>These safety features ensure that states are saved and loaded correctly even in multi-threaded environments.</p>"},{"location":"user-guide/state_persistence/#api-reference","title":"API Reference","text":"<p>More details, Checkout to the API Reference</p>"},{"location":"user-guide/testing/","title":"Test","text":""},{"location":"user-guide/testing/#testing-tools","title":"Testing Tools","text":"<p>The <code>testing</code> module provides tools designed to simplify testing of applications built with the PAMIQ-Core framework. These utilities help streamline the process of connecting components and setting up proper test environments.</p>"},{"location":"user-guide/testing/#connect-components","title":"Connect Components","text":"<p>When testing with PAMIQ-Core, components like Trainers and Agents need to have DataUsers, Collectors, TrainingModels, and InferenceModels attached before they can be properly used. The <code>testing.connect_components</code> function simplifies this process:</p> <pre><code>from pamiq_core.testing import connect_components\n\n# Set up components\nagent = MyAgent()\ntrainer = MyTrainer()\nbuffer = MyDataBuffer([\"state\", \"action\", \"reward\"], max_size=1000)\nmodel = MyTrainingModel()\n\n# Connect all components in one call\ncomponents = connect_components(\n    agent=agent,\n    trainers=trainer,\n    buffers={\"experience\": buffer},\n    models={\"policy\": model}\n)\n\n# Now you can access the connected components\ndata_users = components.data_users\ndata_collectors = components.data_collectors\ntraining_models = components.training_models\ninference_models = components.inference_models\n</code></pre> <p>The function returns a <code>ConnectedComponents</code> named tuple containing all the connected component dictionaries for easy access in your tests.</p>"},{"location":"user-guide/testing/#creating-mock-models","title":"Creating Mock Models","text":"<p>When testing components that interact with models, you often need mock implementations of <code>TrainingModel</code> and <code>InferenceModel</code>. The <code>create_mock_models</code> function creates pre-configured mock model pairs:</p> <pre><code>from pamiq_core.testing import create_mock_models\n\n# Create a standard model pair\ntraining_model, inference_model = create_mock_models()\n\n# Create a training model without inference model\ntraining_model_no_inference, _ = create_mock_models(has_inference_model=False)\n\n# Create an inference-thread-only model\ninference_only_model, inference_model = create_mock_models(inference_thread_only=True)\n\n# Use in tests\nassert training_model.has_inference_model is True\nassert training_model.inference_model is inference_model\n</code></pre>"},{"location":"user-guide/testing/#creating-mock-buffer","title":"Creating Mock Buffer","text":"<p>When testing components that require data buffers, you can quickly create mock buffer instances using the <code>create_mock_buffer</code> function:</p> <pre><code>from pamiq_core.testing import create_mock_buffer\n\n\nbuffers = {\n    # Create a default buffer with max_size=1\n    \"buffer\": create_mock_buffer(),\n    # Create a buffer with custom max_size\n    \"large_buffer\": create_mock_buffer(max_size=1000),\n}\n</code></pre>"},{"location":"user-guide/testing/#api-reference","title":"API Reference","text":"<p>For more detailed information, check out the API Reference</p>"},{"location":"user-guide/testing/#testing-agents","title":"Testing Agents","text":"<p>When testing an Agent implementation, you need to follow this sequence to ensure proper initialization and cleanup:</p> <ol> <li>Connect components</li> <li>Call setup</li> <li>Test the step method</li> <li>Call teardown</li> </ol> <p>For example:</p> <pre><code>def test_my_agent():\n    # Create and connect components\n    agent = MyAgent()\n    buffer = MyDataBuffer([\"state\", \"action\"], max_size=100)\n    model = MyTrainingModel()\n\n    connect_components(\n        agent=agent,\n        buffers={\"experience\": buffer},\n        models={\"policy\": model}\n    )\n\n    # Initialize the agent\n    agent.setup()\n\n    # Test the step method\n    observation = [0.1, 0.2, 0.3]\n    action = agent.step(observation)\n\n    # Verify the action is as expected\n    assert action == 1\n\n    # Clean up\n    agent.teardown()\n</code></pre> <p>Remember that the <code>step</code> method can only be properly tested after components have been connected and <code>setup</code> has been called.</p>"},{"location":"user-guide/testing/#testing-trainers","title":"Testing Trainers","text":"<p>Testing a Trainer implementation follows a similar pattern, with a specific sequence:</p> <ol> <li>Connect components</li> <li>Call setup</li> <li>Test the train method</li> <li>Call sync_models</li> <li>Call teardown</li> </ol> <p>Here's an example:</p> <pre><code>def test_my_trainer():\n    # Create and connect components\n    trainer = MyTrainer()\n    buffer = MyDataBuffer([\"state\", \"action\", \"reward\"], max_size=100)\n    model = MyTrainingModel()\n\n    components = connect_components(\n        trainers=trainer,\n        buffers={\"experience\": buffer},\n        models={\"policy\": model}\n    )\n\n    # Initialize the trainer\n    trainer.setup()\n\n    # Must check the trainer is trainable.\n    assert trainer.is_trainable()\n\n    # Test the train method\n    trainer.train()\n\n    # Sync the models\n    trainer.sync_models()\n\n    # Verify training effects\n    # ...\n\n    # Clean up\n    trainer.teardown()\n</code></pre> <p>While you can use the <code>run</code> method to execute the entire workflow (setup \u2192 train \u2192 sync_models \u2192 teardown), note that it will only execute if <code>is_trainable()</code> returns <code>True</code>. This is important to remember when setting up your test data.</p> <pre><code># Alternative approach using run\ndef test_trainer_run():\n    # Create and connect components\n    trainer = MyTrainer()\n    buffer = MyDataBuffer([\"state\", \"action\", \"reward\"], max_size=100)\n    model = MyTrainingModel()\n\n    connect_components(\n        trainers=trainer,\n        buffers={\"experience\": buffer},\n        models={\"policy\": model}\n    )\n\n    # Prepare test data to ensure is_trainable returns True\n    # ...\n\n    # Run the entire training workflow\n    result = trainer.run()\n\n    # Verify run was successful\n    assert result is True\n\n    # Verify training effects\n    # ...\n</code></pre>"},{"location":"user-guide/torch/","title":"\ud83d\udd25 PyTorch Integration","text":"<p>The <code>torch</code> submodule provides integration with PyTorch for PAMIQ-Core, enabling deep learning models to be used within the multi-threaded adaptive learning architecture.</p>"},{"location":"user-guide/torch/#overview","title":"Overview","text":"<p>PyTorch integration in PAMIQ-Core includes specialized implementations of:</p> <ul> <li> <p>Model Classes:</p> <ul> <li><code>TorchInferenceModel</code>: Wrapper for PyTorch models in the inference thread</li> <li><code>TorchTrainingModel</code>: Wrapper for PyTorch models in the training thread</li> </ul> </li> <li> <p>Trainer Class:</p> <ul> <li><code>TorchTrainer</code>: Base class for implementing PyTorch training algorithms</li> </ul> </li> </ul> <p>These components handle thread-safe model synchronization, optimizer management, and state persistence for PyTorch models.</p>"},{"location":"user-guide/torch/#model-synchronization-architecture","title":"Model Synchronization Architecture","text":"<p>PAMIQ-Core uses an efficient model synchronization mechanism for PyTorch models:</p> <p></p> <p>The synchronization process works as follows:</p> <ol> <li>Training occurs in the training thread, updating the <code>TorchTrainingModel</code></li> <li>When training completes, the <code>sync()</code> method is called</li> <li>Instead of copying parameters to inference model (which would be slow for large models), the models are swapped and copying inference model to training model.</li> <li>Gradient information is preserved during the swap to maintain training continuity</li> <li>The inference thread immediately gets access to the updated model</li> </ol> <p>This approach offers significant performance benefits over parameter copying, especially for large deep learning models.</p>"},{"location":"user-guide/torch/#using-pytorch-models","title":"Using PyTorch Models","text":""},{"location":"user-guide/torch/#creating-a-pytorch-training-model","title":"Creating a PyTorch Training Model","text":"<p>To use a PyTorch model in PAMIQ-Core, wrap it in a <code>TorchTrainingModel</code>:</p> <pre><code>import torch.nn as nn\nfrom pamiq_core.torch import TorchTrainingModel\n\n# Create a PyTorch neural network\nclass SimpleNetwork(nn.Module):\n    def __init__(self):\n        super().__init__()\n        self.fc1 = nn.Linear(10, 64)\n        self.fc2 = nn.Linear(64, 1)\n        self.relu = nn.ReLU()\n\n    def forward(self, x):\n        x = self.relu(self.fc1(x))\n        return self.fc2(x)\n\n# Wrap it in a TorchTrainingModel\nmodel = TorchTrainingModel(\n    model=SimpleNetwork(),\n    has_inference_model=True,\n    inference_thread_only=False,\n    device=\"cuda:0\"  # Optional: specify device\n)\n</code></pre> <p>The <code>TorchTrainingModel</code> provides several important parameters:</p> <ul> <li>model: The PyTorch nn.Module to wrap</li> <li>has_inference_model: Whether to create an inference model (default: True)</li> <li>inference_thread_only: Whether this model is used only for inference (default: False)</li> <li>device: The device to place the model on</li> <li>dtype: The data type to use for the model</li> <li>inference_procedure: Custom inference procedure for specialized models</li> </ul>"},{"location":"user-guide/torch/#using-pretrained-models","title":"Using Pretrained Models","text":"<p>You can load pretrained models by providing the <code>pretrained_parameter_file</code> parameter:</p> <pre><code>pretrained_model = TorchTrainingModel(\n    model=SimpleNetwork(),\n    pretrained_parameter_file=\"path/to/model_weights.pt\"\n)\n</code></pre>"},{"location":"user-guide/torch/#using-the-get_device-function","title":"Using the <code>get_device</code> Function","text":"<p>The <code>get_device</code> function is a helpful utility for determining which device a model is running on:</p> <pre><code>from pamiq_core.torch import get_device\nimport torch.nn as nn\n\n# Create a model\nmodel = nn.Linear(10, 1)\n\n# Check which device it's on\ndevice = get_device(model)  # Returns CPU device by default\nprint(f\"Model is on device: {device}\")\n\n# Move to GPU if available\nif torch.cuda.is_available():\n    model = model.to(\"cuda\")\n    device = get_device(model)  # Now returns CUDA device\n    print(f\"Model moved to device: {device}\")\n</code></pre> <p>This is particularly useful in custom inference procedures:</p> <pre><code>def custom_inference_procedure(model: nn.Module, x: torch.Tensor) -&gt; torch.Tensor:\n    # Get the device where the model runs\n    device = get_device(model)\n\n    # Move input to the same device as the model\n    x = x.to(device)\n\n    # Perform inference\n    with torch.no_grad():\n        return model(x)\n</code></pre>"},{"location":"user-guide/torch/#important-considerations","title":"\u26a0\ufe0f Important Considerations","text":"<p>When using PyTorch models in PAMIQ-Core, be aware of the following:</p> <ol> <li> <p>Model State Management: Since the models are swapped during synchronization, any state stored inside the model (like buffers or running statistics) will also be swapped. This means:</p> <ul> <li>Do not store transient state in the model that shouldn't be shared between threads</li> <li>Be cautious with models that maintain internal state beyond parameters</li> </ul> </li> <li> <p>Device Management: Models are automatically moved to the specified device, but input tensors in custom code must be moved explicitly</p> </li> <li> <p>Thread Safety: The model synchronization ensures thread safety, but you should not directly access the models from multiple threads</p> </li> </ol>"},{"location":"user-guide/torch/#implementing-pytorch-trainers","title":"Implementing PyTorch Trainers","text":""},{"location":"user-guide/torch/#basic-torchtrainer","title":"Basic TorchTrainer","text":"<p>The <code>TorchTrainer</code> class provides a foundation for implementing PyTorch training algorithms:</p> <pre><code>from pamiq_core.torch import TorchTrainer\nimport torch.optim as optim\nfrom typing import override\n\nclass MyPytorchTrainer(TorchTrainer):\n    @override\n    def on_training_models_attached(self) -&gt; None:\n        \"\"\"Called when training models are attached to the trainer.\"\"\"\n        super().on_training_models_attached()\n        # Get model with type checking\n        self.policy_model = self.get_torch_training_model(\"policy\", nn.Sequential)\n        self.value_model = self.get_torch_training_model(\"value\")\n\n    @override\n    def create_optimizers(self) -&gt; dict[str, optim.Optimizer]:\n        \"\"\"Create optimizers for training.\n\n        Returns:\n            Dictionary mapping names to optimizers\n        \"\"\"\n        return {\n            \"policy_optimizer\": optim.Adam(self.policy_model.model.parameters(), lr=0.001),\n            \"value_optimizer\": optim.Adam(self.value_model.model.parameters(), lr=0.001)\n        }\n\n    @override\n    def train(self) -&gt; None:\n        \"\"\"Implement training logic.\"\"\"\n        # Get training data\n        data = self.get_data_user(\"experience\").get_data()\n        states = torch.tensor(data[\"states\"])\n        actions = torch.tensor(data[\"actions\"])\n        rewards = torch.tensor(data[\"rewards\"])\n\n        # Training loop\n        for _ in range(10):  # 10 optimization steps\n            # Forward pass\n            action_logits = self.policy_model(states)\n            values = self.value_model(states)\n\n            # Calculate losses\n            policy_loss = calculate_policy_loss(action_logits, actions, rewards)\n            value_loss = calculate_value_loss(values, rewards)\n\n            # Backward pass and optimize\n            self.optimizers[\"policy_optimizer\"].zero_grad()\n            policy_loss.backward()\n            self.optimizers[\"policy_optimizer\"].step()\n\n            self.optimizers[\"value_optimizer\"].zero_grad()\n            value_loss.backward()\n            self.optimizers[\"value_optimizer\"].step()\n</code></pre>"},{"location":"user-guide/torch/#using-learning-rate-schedulers","title":"Using Learning Rate Schedulers","text":"<p>You can also include learning rate schedulers in your trainer:</p> <pre><code>@override\ndef create_optimizers(self) -&gt; tuple[dict[str, optim.Optimizer], dict[str, optim.lr_scheduler.LRScheduler]]:\n    \"\"\"Create optimizers and schedulers for training.\n\n    Returns:\n        Tuple containing optimizers dictionary and schedulers dictionary\n    \"\"\"\n    # Create optimizers\n    optimizers = {\n        \"policy_optimizer\": optim.Adam(self.policy_model.model.parameters(), lr=0.001)\n    }\n\n    # Create schedulers\n    schedulers = {\n        \"policy_scheduler\": optim.lr_scheduler.ExponentialLR(\n            optimizers[\"policy_optimizer\"],\n            gamma=0.99\n        )\n    }\n\n    return optimizers, schedulers\n</code></pre>"},{"location":"user-guide/torch/#type-checked-model-access","title":"Type-Checked Model Access","text":"<p>The <code>get_torch_training_model</code> method provides type-checked access to PyTorch models:</p> <pre><code># Get any torch model\nmodel = self.get_torch_training_model(\"policy\")\n\n# Get model with type checking - ensures model is a CNN\ncnn_model = self.get_torch_training_model(\"encoder\", nn.Conv2d)\n</code></pre> <p>This provides runtime type checking and helps catch errors early.</p>"},{"location":"user-guide/torch/#optimizer-state-management","title":"Optimizer State Management","text":"<p>The <code>TorchTrainer</code> automatically manages optimizer state across training sessions. This means:</p> <ol> <li>Optimizer states are automatically saved and restored during <code>save_state</code> and <code>load_state</code></li> <li>When models are synchronized, optimizer states are preserved</li> <li>Learning rate scheduler states are also maintained</li> </ol> <p>This ensures training can continue correctly even model swapping or after state loading.</p>"},{"location":"user-guide/torch/#advanced-usage","title":"Advanced Usage","text":""},{"location":"user-guide/torch/#custom-inference-procedures","title":"Custom Inference Procedures","text":"<p>You can define custom inference procedures for specialized needs:</p> <pre><code>def my_inference_procedure(model: nn.Module, input_tensor: torch.Tensor) -&gt; torch.Tensor:\n    \"\"\"Custom inference procedure for a specific model architecture.\"\"\"\n    # Preprocessing\n    processed_input = input_tensor / 255.0\n\n    # Run model with gradient accumulation disabled\n    with torch.no_grad():\n        output = model(processed_input)\n\n    # Postprocessing\n    return torch.softmax(output, dim=1)\n\n# Use the custom procedure\nmodel = TorchTrainingModel(\n    model=MyNetwork(),\n    inference_procedure=my_inference_procedure\n)\n</code></pre>"},{"location":"user-guide/torch/#api-reference","title":"API Reference","text":"<p>More details, Checkout to the API Reference</p>"},{"location":"user-guide/trainer/","title":"Trainer","text":"<p>The <code>trainer</code> module defines how models are trained during system operation. It manages the training process, decides when to train, and handles synchronization between training and inference models.</p>"},{"location":"user-guide/trainer/#basic-concepts","title":"Basic Concepts","text":"<p>Trainers in PAMIQ-Core operate in the training thread, processing data collected during inference. The key responsibilities of a trainer include:</p> <ol> <li>Deciding when to train: Using data availability conditions to determine if training should occur</li> <li>Executing training logic: Implementing the actual learning algorithm</li> <li>Synchronizing models: Ensuring updated parameters are available for inference</li> </ol> <p>The training process flows as follows:</p> <ol> <li>Check if training conditions are met via <code>is_trainable()</code></li> <li>Run setup via <code>setup()</code></li> <li>Execute training via <code>train()</code></li> <li>Synchronize models via <code>sync_models()</code></li> <li>Clean up resources via <code>teardown()</code></li> </ol>"},{"location":"user-guide/trainer/#implementing-custom-trainers","title":"Implementing Custom Trainers","text":"<p>To implement a custom trainer, you need to extend the <code>Trainer</code> class and override the <code>train</code> method:</p> <pre><code>from pamiq_core import Trainer\nfrom typing import override\n\nclass MyTrainer(Trainer):\n    \"\"\"Custom trainer that implements a simple learning algorithm.\"\"\"\n\n    @override\n    def train(self) -&gt; None:\n        \"\"\"Implement the training logic.\n\n        This method is called repeatedly by the training thread when\n        conditions for training are met.\n        \"\"\"\n        # Get the model\n        model = self.get_training_model(\"policy_model\")\n\n        # Training logic\n        for _ in range(10):  # 10 optimization steps\n            # ... implement training algorithm\n            pass\n\n        # Model parameters will be automatically synchronized after training\n</code></pre>"},{"location":"user-guide/trainer/#training-conditions","title":"Training Conditions","text":"<p>PAMIQ-Core trainers can be configured with conditions to determine when training should occur:</p> <pre><code># Create a trainer that only trains when:\n# 1. The \"experience\" buffer has at least 1000 samples\n# 2. At least 100 new samples have been collected since last training\ntrainer = MyTrainer(\n    training_condition_data_user=\"experience\",\n    min_buffer_size=1000,\n    min_new_data_count=100\n)\n</code></pre> <p>You can also implement custom training conditions by overriding the <code>is_trainable</code> method:</p> <pre><code>@override\ndef is_trainable(self) -&gt; bool:\n    \"\"\"Determine if training should be executed.\n\n    Returns:\n        True if training should proceed, False otherwise\n    \"\"\"\n    # Check parent condition first\n    if not super().is_trainable():\n        return False\n\n    # Add custom condition - only train during daytime\n    current_hour = datetime.now().hour\n    return 8 &lt;= current_hour &lt;= 20\n</code></pre>"},{"location":"user-guide/trainer/#accessing-training-models","title":"Accessing Training Models","text":"<p>To access models for training, override the <code>on_training_models_attached</code> callback:</p> <pre><code>@override\ndef on_training_models_attached(self) -&gt; None:\n    \"\"\"Called when training models are attached to the trainer.\"\"\"\n    # Store references to models for convenient access\n    self.policy_model = self.get_training_model(\"policy\")\n    self.value_model = self.get_training_model(\"value\")\n</code></pre>"},{"location":"user-guide/trainer/#using-experience-data","title":"Using Experience Data","text":"<p>To access collected data for training, override the <code>on_data_users_attached</code> callback:</p> <pre><code>@override\ndef on_data_users_attached(self) -&gt; None:\n    \"\"\"Called when data users are attached to the trainer.\"\"\"\n    # Store references to data users for convenient access\n    self.experience_data = self.get_data_user(\"experience\")\n\n@override\ndef train(self) -&gt; None:\n    \"\"\"Train models using collected experience data.\"\"\"\n    # Update to get latest data\n    self.experience_data.update()\n\n    # Access the data\n    data = self.experience_data.get_data()\n    states = data[\"state\"]\n    actions = data[\"action\"]\n    rewards = data[\"reward\"]\n\n    # Use the data to train models\n    # ...\n</code></pre>"},{"location":"user-guide/trainer/#lifecycle-callbacks","title":"Lifecycle Callbacks","text":"<p>PAMIQ-Core trainers have several lifecycle callbacks that you can override:</p>"},{"location":"user-guide/trainer/#setup-and-teardown","title":"Setup and Teardown","text":"<pre><code>@override\ndef setup(self) -&gt; None:\n    \"\"\"Called before training starts.\n\n    Use this to initialize resources needed for training.\n    \"\"\"\n    super().setup()  # Always call the parent method\n\n    # Initialize training resources\n    self.optimizer = SomeOptimizer(self.policy_model.parameters())\n    self.batch_size = 64\n\n@override\ndef teardown(self) -&gt; None:\n    \"\"\"Called after training finishes.\n\n    Use this to clean up resources after training.\n    \"\"\"\n    super().teardown()  # Always call the parent method\n\n    # Clean up resources\n    self.optimizer = None\n</code></pre>"},{"location":"user-guide/trainer/#thread-events","title":"Thread Events","text":"<p>As with other PAMIQ-Core components, trainers can respond to system pause and resume events:</p> <pre><code>@override\ndef on_paused(self) -&gt; None:\n    \"\"\"Called when the system is paused.\"\"\"\n    super().on_paused()  # Always call the parent method\n\n    # Pause external connections or resources\n    if hasattr(self, 'external_service'):\n        self.external_service.pause()\n\n@override\ndef on_resumed(self) -&gt; None:\n    \"\"\"Called when the system is resumed.\"\"\"\n    super().on_resumed()  # Always call the parent method\n\n    # Resume external connections or resources\n    if hasattr(self, 'external_service'):\n        self.external_service.resume()\n</code></pre> <p>These event hooks enable proper resource management in response to system state changes.</p>"},{"location":"user-guide/trainer/#pytorch-integration","title":"PyTorch Integration \ud83d\udd25","text":"<p>For training deep learning models, PAMIQ-Core provides specialized trainer classes in the <code>torch</code> submodule.</p> <p>For more details on using PyTorch with PAMIQ-Core, see the PyTorch Integration Guide.</p>"},{"location":"user-guide/trainer/#api-reference","title":"API Reference","text":"<p>More details, Checkout to the API Reference</p>"}]}